# Search Results for: what should be the size of my ensamble for pest ies?

Keywords: None

## Variations
1. what should be the size of my ensamble for pest ies?
2. describe the proper size of my ensamble for pest ies
3. tell me about the size of my ensamble for pest ies
4. what is the ideal size of my ensamble for pest ies?
5. explain the size requirements for my ensamble for pest ies


## Context

### Summary
**For large problems, use 64-bit versions of PEST, Parallel PEST, BEOPEST, and their utilities for faster execution and increased memory capacity.**

### Header
**15.3 Versions of PEST**

### Content
Where problem sizes are large, use 64 bit versions of PEST, Parallel PEST and BEOPEST (and of PEST support utilities for which 64 bit versions are provided). Execution is generally faster. Much more memory can be addressed.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 15. Large Numbers of Parameters
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** This chapter discusses efficient calibration methods for models with tens of thousands of parameters using PEST. Adjoint techniques are recommended for highly parameterized models. Use compressed binary external derivatives files, 64-bit versions of PEST for large problems, and optimize Jacobian matrix storage. Prioritize linearity of regularization constraints and activate memory conservation for improved efficiency.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** For highly parameterized models (tens of thousands), model-calculated derivatives (adjoint techniques, Chapter 12) are necessary due to the excessive number of model runs and imprecision of finite differences.  Compressed binary external derivatives files are recommended; elements should be ordered by observation then parameter for optimal efficiency.
- **Next Summary:** In highly parameterized inversions, Jacobian matrix storage (dimensions (no+np)×m) can be excessive.  Many sensitivities and Tikhonov regularization elements are often zero. A data storage mechanism that omits zero-valued elements significantly reduces PEST's memory requirements.

### Metadata
- **Keywords:** 
- **Chunk ID:** 99e9db574a30
- **Chunk Index:** 1
- **Previous Chunk ID:** 5d358602f4e2
- **Next Chunk ID:** 8c1f42813f75

---

## Context

### Summary
**Verify the DSI2-generated PEST control file (case.pst) using PESTCHEK (it will not approve case_sd.pst if created). Run PESTPP-IES using `pestpp-ies case` or `pestpp-ies case_sd` (depending on whether standard deviations are provided). Monitor case.phi.actual.csv;  accept results at or near the target objective function value (≈number of non-zero-weighted observations). Use case.J.obs.csv (N realizations) to create posterior prediction histograms.**

### Header
**18.3.7 Running PESTPP-IES**

### Content
Once DSI2 has written its PEST input dataset, the entire dataset can be checked using PESTCHEK. Suppose that the DSI2‑produced PEST control file is named case.pst. Then PESTCHEK can be run using the command:
pestchek case
Note, however, that if a secondary PESTPP‑IES‑only PEST control file is written, then PESTCHECK will not approve of this file, for it does not support the use of external observation data files. (However PESTPP‑IES will happily read this file.)
PESTPP‑IES can then be run using the command:
pestpp-ies case
or
pestpp-ies case_sd
depending on whether or not a user specifically provides standard deviations of measurement noise.
If measurement noise standard deviations are “correct”, or if only weights are supplied and they are equal to the inverse standard deviations of measurement noise, the objective function should be reduced to a value that is about equal to the number of non‑zero‑weighted
observations. PESTPP‑IES should be prevented from reducing the objective function below this. Monitor file case.phi.actual.csv to see the iteration number at which the desired value of the objective function is achieved. If necessary, accept results from a few iterations before the last iteration which PESTPP‑IES undertakes (or halt PESTPP‑IES execution when the objective function is lowered to the desired value).
Suppose that a suitable objective function value is achieved at iteration J. Posterior predictive histograms can be constructed using the contents of file case.J.obs.csv. This contains N realisations of all predictions, where N is the number of user‑requested PESTPP‑IES realisations.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software
- **Main Section:** 18. Data Space Inversion
- **Subsection:** 18.3 DSI2, DSIMOD and POSTDSIMOD

### Additional Summaries
- **Higher-Level Summary:** The text describes using soil clod shrinkage data to fit two straight lines using Equation 18.1.1 with parameters s1, s2, y1, and xc in the pestex subfolder. The TWOLINE program reads parameters and water contents from in.dat, adjusts parameters using PEST, and generates input files for calculations. The final prediction value is 0.786.
- **Detailed Summary:** DSI2 creates files for data space inversion using PESTPP-IES or PEST_HP, computing an empirical covariance matrix from a CSV file of model outputs. It uses a PEST control file's weights for observations, creating a new control file for history-matching. Posterior predictive uncertainty analysis with PEST_HP involves multiple steps, including running the model NREAL times and calibrating with regularization. Linear analysis is an alternative method.

### Related Context
- **Previous Summary:** DSIMOD (a surrogate model) calculates model outputs.  It's run using `dsimod infile parfile outfile`, where infile (binary, from DSI2) contains transformation variables, d, and C½(d); parfile lists PCA parameter values; and outfile contains the calculated outputs.  Filenames share a common base (from DSI2).
- **Next Summary:** To get posterior prediction means, add regularization to case.pst using ADDREG2 (`addreg2 case case1 target continue`), run PEST (stopping when the solution is deemed sufficient), and obtain predictions from case1.rec or case1.res. For better results, use PEST_HP (`addreg2 case case1 target continue hp`, UPTESTMIN=25), adjusting PHIMLIM until outputs are satisfactory.  Use PARREP to create case_soln.pst (NOPTMAX=0) for a final model run using `pest case_soln /hpstart`.

### Metadata
- **Keywords:** 
- **Chunk ID:** 09cd4afd25d3
- **Chunk Index:** 1
- **Previous Chunk ID:** ac464f91a7cb
- **Next Chunk ID:** 40c1a16585ed

---

## Context

### Summary
**Parallel PEST's efficiency decreases with short model run times due to file I/O and message passing latency. BEOPEST, using TCP/IP, minimizes these overheads because agents perform file I/O locally.**

### Header
**11.1.4 Communication Overheads**

### Content
If model run times are short, gains in computational efficiency that are achievable using Parallel PEST will not be as great as when model times are large, for the time taken in writing and reading (possibly lengthy) model input and output files across a local area network may then become large in comparison with model run times. Another contributor to parallelisation latency is the use of message files for communication between manager and agents. It may take a number of seconds before a message issued by one is received by the other.
Because it uses TCP/IP for messaging, and because the BEOPEST agent writes model input files and reads model output files locally, manager/agent communication overheads are very low for BEOPEST.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 11. Parallel PEST and BEOPEST (continuación)
- **Subsection:** 11.1 General (continuación)

### Additional Summaries
- **Higher-Level Summary:** Parallel PEST and BEOPEST parallelize model runs to reduce run time. Parallel PEST needs a run management file, while BEOPEST's is optional. Both distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Parallel PEST uses PAGENT agents, requires separate folders for agents, and shared signal files for communication. BEOPEST offers ease of use, faster communication, flexibility, and support for multiple command lines and surrogate models.
- **Detailed Summary:** Parallel PEST and BEOPEST parallelize model runs, reducing PEST run time. Parallel PEST requires a run management file, while BEOPEST's is optional. They distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Both store data in binary files for reduced memory needs.

### Related Context
- **Previous Summary:** Parallel PEST/BEOPEST partially parallelizes Marquardt lambda testing by running models with multiple lambdas (related by RLAMFAC) simultaneously.  Some runs may be wasted, but idle processors are avoided.  Parallel lambda testing may be disabled in "predictive analysis" mode (line search) or if parameters hit bounds.
- **Next Summary:** Parallel PEST (ppest.exe, i64ppest.exe) and BEOPEST (beopest32.exe, beopest64.exe) are automatically installed.  PAGENT.exe is required for Parallel PEST on each agent machine; BEOPEST uses its own executable as the agent.  Model programs and files must also be copied to agent machines before running Parallel PEST or BEOPEST.

### Metadata
- **Keywords:** 
- **Chunk ID:** cb0f0bfcff07
- **Chunk Index:** 1
- **Previous Chunk ID:** df6c96c24b07
- **Next Chunk ID:** 3de0f3c0071a

---

## Context

### Summary
**DSI's performance diminishes with fewer than 100 realizations, especially when subtracting large numbers to calculate posterior uncertainty (more pronounced in Gaussian space). Out-of-range confidence limits may result from incompatible prior parameter distributions and measurements.  Avoid Gaussian transformation if posterior bounds coincide.  High prior parameter variances or avoiding high prior mean values may mitigate this.**

### Header
**18.1.5 Experience and Recommendations**

### Content
For cases on which performance of DSI has been tested so far, the outcomes of its calculations appear to be reasonable. However its performance seems to deteriorate where the number of realizations used for calculation of C22 and C12 is less than about 100. Conceptually, C12 should be calculated without noise enhancement of model outputs. However C22 should include the effects of measurement noise. This can create problems with implementation of equation (18.1.5), especially where prior predictive uncertainties are high and posterior predictive uncertainties are low, for this requires the subtraction of two large numbers to obtain a smaller one without a mathematical guarantee that the resulting number will be greater than zero. This appears to affect calculations undertaken in Gaussian transformation space more than calculations that are not undertaken in this space. This problem becomes apparent to the user if posterior predictive uncertainty upper and lower bounds are calculated to coincide. Hence there appear to be circumstances where use of a Gaussian transformation should be avoided.
Nevertheless, a benefit of working in Gaussian space is that DSI prints the realization rank of each observation at the end of its output file. This provides a check that observations are compatible with the prior parameter probability distribution; ideally all observations should have a realization rank which is greater than zero and less than NREAL. If this is not the case, the performance of DSI may be degraded. In particular, DSI may not be able to calculate upper and/or lower predictive confidence limits. Instead it may simply indicate that these are below/above the smallest/largest value recorded for that prediction in the RRF file from which it obtained predictive values. This is an outcome of the fact that normal score transformation (undertaken as a precursor to Gaussian transformation) cannot proceed beyond the limits of available data on which to base this transformation.
Where performance of DSI is degraded because of an apparent conflict between the prior probability distribution ascribed to parameters on the one hand, and to historical
measurements of system state used in the calibration process on the other hand, then DSI can, of course, still be profitably used without working in Gaussian transform space.
In some contexts, some simple steps can be taken to avoid the problem of out‑of‑range predictive confidence limits. Obviously, assignment of higher values to prior parameter variances may ensure that observations fall within model‑calculated ranges. Other precautions may be more subtle (but just as effective). For example, if working with a groundwater model, it may be wise to avoid the assumption of a high prior mean permeability value, for this may promulgate low vertical and lateral gradients in model‑calculated heads at the same time as it promulgates insensitivity of these heads to parameters. If real‑world permeabilities are in fact low, then observed heads may not lie within model‑calculated ranges for these heads when prior parameter variances are superimposed on a high prior mean.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software
- **Main Section:** 18. Data Space Inversion
- **Subsection:** 18.1 DSI

### Additional Summaries
- **Higher-Level Summary:** The text describes using soil clod shrinkage data to fit two straight lines using Equation 18.1.1 with parameters s1, s2, y1, and xc in the pestex subfolder. The TWOLINE program reads parameters and water contents from in.dat, adjusts parameters using PEST, and generates input files for calculations. The final prediction value is 0.786.
- **Detailed Summary:** The example in the pestex subfolder fits two straight lines to soil clod shrinkage data for residual and normal shrinkage. The model uses Equation 18.1.1 with parameters s1, s2, y1, and xc. Program TWOLINE in the pestex folder reads parameters and water contents from in.dat, calculates specific volumes, and adjusts parameters using PEST to minimize discrepancies with laboratory data.

### Related Context
- **Previous Summary:** The DSI output file (Figure 18.2) echoes user inputs, including minimum/maximum prediction values. It then presents prior and posterior predictive confidence intervals (68% and 95%) in both Gaussian and untransformed spaces. Out-of-range confidence limits/means may indicate model nonlinearity, non-Gaussian noise, or inappropriate prior parameter uncertainties. If Gaussian transformation is used, realization ranks of calibration observations are listed; out-of-bounds ranks (0 and NREAL+1) are counted.
- **Next Summary:** DSI1 functions identically to DSI but reads CSV files (PESTPP-IES format) instead of RRF files. It prompts for calibration and prediction CSV files; calibration files require all observations (same order as the PEST control file), while prediction files require only the prediction column (realization order must match).  Realization names are not cross-checked.  A single file can contain both calibration and prediction data.

### Metadata
- **Keywords:** 
- **Chunk ID:** 7704e6f5153a
- **Chunk Index:** 1
- **Previous Chunk ID:** 44a66fcfc0fb
- **Next Chunk ID:** d9473c88b79c

---

## Context

### Summary
**Bounds-sticking (IBOUNDSTICK) prevents wasted model runs by fixing parameters at bounds after a specified number of iterations.  Upgrade vector bending (UPVECBEND) avoids shortening the upgrade vector when parameter change limits are reached, potentially improving performance but may degrade it.  Parameter change limits maintain inversion stability.**

### Header
**3.4.5 Optional Alternative Bounds Accommodation**

### Content
If a model takes a long time to run, then any measures that can be taken to reduce the number of runs required for estimation of its parameters makes that model more useable with PEST. Parameter “bounds-sticking” functionality is one such measure.
When one or more parameters are at their bounds, the procedure by which the parameter upgrade vector is calculated is modified to accommodate this situation. If, for one such parameter, the parameter upgrade vector is such that the parameter is directed away from its bound back into “allowed parameter space”, then that parameter is free to move as it normally would. However parameters for which the upgrade vector points outside of allowed parameter space (i.e. above or below the upper or lower bound at which the parameter currently resides) are sequentially frozen; the sequence in which these parameters are frozen is important; see Doherty (2015). On each occasion that a parameter is frozen, the parameter upgrade vector is re-calculated with currently frozen parameters omitted from the parameter upgrade calculation. At the beginning of each new iteration, all frozen parameters are freed. The whole process is then repeated during the next iteration of the inversion process.
Sometimes a parameter can move to its bound, and then back again into allowed parameter space, during the course of a single inversion process. However if a parameter is at its bound for more than a few iterations, it is more likely than not that the parameter is there to stay. However PEST will continue to calculate derivatives with respect to this parameter in order to attempt an upgrade calculation for it, even though there is a diminishing likelihood that the parameter will ever move from its bounds. Thus one model run per iteration (more if PEST is engaged in higher order finite-difference derivatives calculation) is wasted. Where more than one parameter is at its bound the number of wasted model runs rises in proportion to the number of such parameters.
Through use of the IBOUNDSTICK control variable residing in the “control data” section of the PEST control file, this wastage of model runs can be prevented. PEST can be instructed to permanently “glue” a parameter to its upper or lower bound if that parameter has been residing there for a user-specified number of iterations. Once a parameter is “glued” to its bound it will never move again, for PEST will no longer include this parameter in its upgrade vector calculations. Nor will it calculate derivatives with respect to this parameter, thus reducing the number of model runs required per iteration.
Despite the potential for model run economy that it offers, bounds-sticking functionality should be used with caution.
The UPVECBEND variable (which follows the IBOUNDSTICK variable in the “control data” section of the PEST control file) activates “upgrade parameter vector bending” functionality. Experience has demonstrated that, while this may result in a slight reduction in
the number of model runs required for completion of the parameter estimation process in some situations, it can seriously degrade PEST’s performance in other situations. Hence it should be used only with extreme caution.
As is described by Doherty (2015), and also below, the length of the parameter upgrade vector is limited during any one PEST iteration by the action of factor, relative and/or absolute parameter change limits. Imposition of limits prevents parameter changes from exceeding by too great a margin the range of the linearity assumption upon which their calculation is based. In doing so, it brings stability to the inversion process.
If PEST calculates that a particular parameter must incur a factor, relative or absolute change which is greater than that permitted by pertinent user-supplied limits, then the changes incurred by all parameters are reduced so that the change incurred by the maximally-changed parameter does not exceed its limit; that is, the length of the upgrade vector is reduced to respect this limit while its direction remains unchanged. As it is often the most insensitive parameters for which the largest change is calculated (especially if regularisation is omitted from a PEST control file), it is on behalf of these parameters that the parameter upgrade vector may thus be shortened. If this is the case, then changes incurred by the more important, sensitive, parameters can thus be curtailed by this shortening of the parameter upgrade vector. This may slow the inversion process.
The UPVECBEND variable can instruct PEST not to shorten the parameter upgrade vector in its observance of parameter change limits. Instead it will “bend” this vector so that, while individual parameters are forced to respect their change limits, other parameters can move by the amount dictated by the parameter upgrade vector. Hence changes calculated for sensitive parameters are not restricted by the change limits imposed on more insensitive parameters.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 3. What PEST Does
- **Subsection:** 3.4 Parameter Adjustment

### Additional Summaries
- **Higher-Level Summary:** This chapter introduces PEST, a tool for solving inverse problems in four modes: "estimation", "predictive analysis", "regularisation", and "pareto". It uses control files with specific sections and options for parameter adjustments, transformations, and derivative calculations. PEST generates Jacobian matrices and offers utilities for file manipulation and sensitivity analysis.
- **Detailed Summary:** The PEST control file's "parameter data" section manages parameter adjustments, including logarithmic transformations for stability. PARTRANS specifies parameter transformations, with options for fixed, log-transformed, or tied parameters. Bounds, scaling, and offsetting are used to prevent model errors and enhance stability. Parameter changes are limited to prevent over-adjustment. Dampening methods reduce oscillations during optimization.

### Related Context
- **Previous Summary:** PARLBND and PARUBND variables in the PEST control file specify parameter upper and lower bounds.  Wise bound selection prevents model errors (e.g., negative values where logarithms are used).  Bound enforcement enhances inversion stability (see Doherty 2015, section 5.4.2.7).
- **Next Summary:** SCALE and OFFSET (in the "parameter data" section) are applied to parameter values before writing to model input files.  They are useful for parameter transformations (e.g., elevation to thickness) and handling negative parameters.  SCALE=1 and OFFSET=0 indicate no scaling or offsetting.  These are applied only when writing to model input files.

### Metadata
- **Keywords:** IBOUNDSTICK, UPVECBEND
- **Chunk ID:** ac9101194d69
- **Chunk Index:** 1
- **Previous Chunk ID:** 4531f5bdc764
- **Next Chunk ID:** 30c3fca934b4

---
