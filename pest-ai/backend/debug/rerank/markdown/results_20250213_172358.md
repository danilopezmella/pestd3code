# Search Results for: What is RLAMBDA1?

Keywords: rlambda1

## Variations
1. What is RLAMBDA1?
2. Please explain what RLAMBDA1 is
3. Could you describe RLAMBDA1?
4. Tell me about RLAMBDA1
5. Define RLAMBDA1


## Context

### Summary
**RLAMBDA1 (initial Marquardt lambda, ~10.0) and RLAMFAC (Marquardt lambda adjustment factor, ~2.0 or -3.0) control lambda adjustments during iterations.  PHIRATSUF (objective function reduction ratio, ~0.3) determines iteration completion; if not met, PHIREDLAM is used.**

### Header
**4.2.6 Fifth Line**

### Content
RLAMBDA1
This real variable is the initial Marquardt lambda. As discussed in the previous section, each iteration of the inversion process undertaken by PEST is divided into two parts. The first part comprises calculation of the Jacobian matrix. The second part is devoted to the testing of parameter upgrades that are calculated using different values of the Marquardt lambda. The role of the Marquardt lambda is described in section 5.4.2 of Doherty (2015).
During any one iteration of the inversion process PEST attempts parameter improvement using a number of different Marquardt lambdas. The starting value of the Marquardt lambda during any one iteration is inherited from the previous iteration; it is generally somewhat lower than that which allowed calculation of the lowest objective function during that iteration. Over the course of the entire inversion process the Marquardt lambda should generally fall. However it may rise if an inverse problem is poorly posed.
RLAMBDA1 is the initial value of the Marquardt lambda. This informs PEST of the first value that it should test during the first iteration of the inversion process. A value of 10.0 is appropriate in most cases. However if PEST complains about the normal matrix being singular you may need to raise it. (A better alternative would be to add regularisation to the PEST control file and/or employ singular value decomposition or LSQR as a solution mechanism for the inverse problem.)
RLAMFAC
RLAMFAC, a real variable, is the factor by which PEST adjusts the Marquardt lambda as it tests different values of this variable for their efficacy in lowering the objective function. RLAMFAC must be greater than 1.0; a value of 2.0 seems to work well on many occasions.
When PEST reduces lambda it divides by RLAMFAC; when it increases lambda it multiplies by RLAMFAC. PEST reduces lambda if it can. However if the inverse problem is nonunique and is unsupplemented by regularisation or by use of singular value decomposition or LSQR as a solution device, or if a reduction in lambda does not lower the objective function, PEST has no choice but to increase lambda.
Alternatively, the Marquardt lambda can be given a negative value less than -1.0. Suppose that it is given a value of -3.0. Then PEST will adjust the lambda adjustment factor during each iteration of the inversion process so that lambda can achieve a value of 1.0 with three adjustments (if PEST decides to move it in this direction). This allows rapid adjustment of the Marquardt lambda if this is suddenly required, as can happen if local parameter insensitivity.
promulgates sudden problem ill-posedness.
More specifically, suppose that RLAMFAC is supplied as –r where r is positive. Let λ be the value of the Marquardt lambda at the beginning of a particular iteration, this being inherited from the previous iteration as described above. Then a Marquardt lambda adjustment factor f for use in the current iteration is calculated as follows.
f = min[λ1/r, 2.0] if λ > 1.0 (4.2.1a)
f = min[(1/λ)1/r, 2.0] if λ < 1.0 (4.2.1b)
f = 2.0 if λ = 1.0 (4.2.1c)
If supplying a negative value for RLAMFAC it is important to note that the higher the absolute value assigned to a negative RLAMFAC, the smaller will be the actual iteration-specific Marquardt lambda adjustment factor. This is opposite to the case for a positive setting of RLAMFAC. In both cases however, the absolute value of RLAMFAC must be greater than 1.0.
An RLAMFAC value of -3.0 works well on most occasions.
PHIRATSUF
During any one iteration of the inversion process, PEST may calculate a parameter upgrade vector using a number of different Marquardt lambdas. First it lowers lambda and, if this is unsuccessful in lowering the objective function, it then raises lambda. If, at any stage, it calculates an objective function which is a fraction PHIRATSUF or less of the starting objective function for that iteration, PEST considers that the goal of the current iteration has been achieved and moves on to the next iteration. Thus PEST will commence iteration i+1 if, at any stage during iteration i
Φij/Φi-1 ≤ PHIRATSUF (4.2.2)
where Φi-1 is the lowest objective function calculated for iteration i-1 (and hence the starting value for iteration i) and Φj is the objective function corresponding to a parameter set i calculated using the j’th Marquardt lambda tested during iteration i.
PHIRATSUF (which stands for “phi ratio sufficient”) is a real variable for which a value of 0.3 is mostly appropriate. If it is set too low, model runs may be wasted in search of an objective function reduction which it is not possible to achieve, given the linearity approximation upon which the inversion equations described in Doherty (2015) are based. If it is set too high, PEST may not be given the opportunity of refining lambda in order that its value continues to be optimal as the inversion process progresses.
PHIREDLAM
If a new/old objective function ratio of PHIRATSUF or less is not achieved as the effectiveness of different Marquardt lambdas in lowering the objective function is tested, PEST must use some other criterion in deciding when it should move on to the next iteration. This criterion is partly provided by the real variable PHIREDLAM.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 4. The PEST Control File
- **Subsection:** 4.2 Control Data Section

### Additional Summaries
- **Higher-Level Summary:** Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.
- **Detailed Summary:** Figure 4.2 shows "control data" section variables (from Appendix A, Figure A1.1).  Some variables are discussed later. The first line must be "* control data";  some variables are optional (in brackets).

### Related Context
- **Previous Summary:** DERZEROLIM (optional) defines a Jacobian matrix zero threshold for compressed storage. NTPLFLE is the number of template files; NINSFLE is the number of instruction files. PRECIS ("single" or "double") sets precision. DPOINT ("point" or "nopoint") controls decimal point inclusion. NUMCOM, JACFILE, MESSFILE (Chapter 12) handle model-calculated derivatives. OBSREREF (Chapter 14) activates observation re-referencing.
- **Next Summary:** PEST iteratively adjusts Marquardt lambda (RLAMBDA1, RLAMFAC) to minimize the objective function.  It stops when the objective function reduction is less than PHIRATSUF or PHIREDLAM (Equation 4.2.3). NUMLAM limits lambda tests per iteration.  JACUPDATE (optional) enables Broyden Jacobian updates. LAMFORGIVE ("lamforgive" or "nolamforgive") handles model run failures.

### Metadata
- **Keywords:** PHIRATSUF, PHIREDLAM, RLAMBDA1, RLAMFAC, lambdas
- **Chunk ID:** 9b975b5255bb
- **Chunk Index:** 1
- **Previous Chunk ID:** e611a7673cad
- **Next Chunk ID:** 2995daaa6e7c

---

## Context

### Summary
**PEST iteratively adjusts Marquardt lambda (RLAMBDA1, RLAMFAC) to minimize the objective function.  It stops when the objective function reduction is less than PHIRATSUF or PHIREDLAM (Equation 4.2.3). NUMLAM limits lambda tests per iteration.  JACUPDATE (optional) enables Broyden Jacobian updates. LAMFORGIVE ("lamforgive" or "nolamforgive") handles model run failures.**

### Header
**4.2.6 Fifth Line**

### Content
The first lambda that PEST employs in calculating the parameter upgrade vector during any particular iteration is the lambda inherited from the previous iteration, possibly reduced by a factor of RLAMFAC (unless it is the first iteration, in which case RLAMBDA1 is used). Unless, through the use of this lambda, the objective function is reduced to less than PHIRATSUF of its value at the beginning of the iteration, PEST then tries another lambda,
less by a factor of RLAMFAC than the first. If the objective function is lower than for the first lambda (and still above PHIRATSUF of the starting objective function), PEST reduces lambda yet again; otherwise it increases lambda to a value greater by a factor of RLAMFAC than the first lambda for the iteration. If, in its attempts to find a more effective lambda by lowering and/or raising lambda in this fashion, the objective function begins to rise, PEST accepts the lambda and the corresponding parameter set giving rise to the lowest objective function for that iteration, and moves on to the next iteration. Alternatively if the relative reduction in the objective function between the use of two consecutive lambdas is less than PHIREDLAM, PEST takes this as an indication that it is probably more efficient to begin the next iteration than to continue testing the effect of new Marquardt lambdas. Thus if
(j-1 - j)/j-1 ≤ PHIREDLAMi i i (4.2.3)
where ij is the objective function value calculated during optimisation iteration i using the j’th trial lambda, PEST moves on to iteration i+1.
A suitable value for PHIREDLAM is between 0.01 and 0.05. If it is set too large, the criterion for moving on to the next iteration is too easily met and PEST is not given the opportunity of adjusting lambda to its optimal value for that particular stage of the parameter estimation process. On the other hand if PHIREDLAM is set too low, PEST will test too many Marquardt lambdas on each iteration of the inversion process when it would be better off starting a new iteration. (Note that where model runs are parallelised, the testing of too many Marquardt lambdas may not be so much of an issue as it keeps otherwise idle processors busy.)
NUMLAM
This integer variable places an upper limit on the number of lambdas that PEST will test during any one iteration. It should normally be set between 5 and 10 (normally closer to 10); however if RLAMBDA1 is set to zero (which is not recommended) it must be set to 1.
JACUPDATE
The Broyden Jacobian update procedure is described in section 5.4.2 of Doherty (2015). It provides a mechanism for improving the Jacobian matrix based on model outputs calculated during model runs undertaken for the purpose of testing parameter upgrades calculated using different values of the Marquardt lambda.
If JACUPDATE is omitted from the fifth line of the “control data” section of the PEST control file, or if it is set to zero, Broyden updating of the Jacobian matrix does not occur. However if it is set to n, where n is a positive integer, Broyden updating will be undertaken during the second part of every PEST iteration following the first n attempts to upgrade parameters using n different values of the Marquardt lambdas. Alternatively, it can be set to 999. In this case the Jacobian matrix is updated after the first parameter upgrade attempt, and every parameter upgrade attempt thereafter.
Experience indicates that Broyden Jacobian updating can work well on most occasions, but on some occasions does not. At the time of writing it is difficult to predict when it is likely to work well and when the opposite is likely to occur. The “safest” option is not to activate it as it can, under some circumstances, actually hinder the progress of the inversion process. Still, these occasions appear to be relatively rare, and in the majority of cases it is worth a try.
LAMFORGIVE
Sometimes, when a model is provided with a particular set of parameters, it fails to run to completion. Its output file is not then written. PEST reports this error condition and ceases execution with an appropriate error message. This situation is most likely to arise during those phases of the parameter estimation process where PEST is altering the value of the Marquardt lambda and testing new upgraded parameter values; this is the stage of the inversion process where parameters provided to the model are most different from their predecessors, and hence where model run failure is most likely to occur.
In most deployment contexts, a better course of action for PEST to take is to ignore the failed model run and attempt calculation of further parameter upgrades using other values of the Marquardt lambda. This response to model run failure can be instigated using the LAMFORGIVE variable.
LAMFORGIVE should be placed on the fifth line of the “control data” section of the PEST control file following the JACUPDATE variable if it is present, or the NUMLAM variable if JACUPDATE is absent. (Actually LAMFORGIVE can be placed in front of the JACUPDATE variable if desired.) It must be supplied as “lamforgive” (to activate model run failure forgiveness) or “nolamforgive” (to de-activate model run failure forgiveness). If it is omitted, a default value of “nolamforgive” is used by PEST.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 4. The PEST Control File
- **Subsection:** 4.2 Control Data Section

### Additional Summaries
- **Higher-Level Summary:** Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.
- **Detailed Summary:** Figure 4.2 shows "control data" section variables (from Appendix A, Figure A1.1).  Some variables are discussed later. The first line must be "* control data";  some variables are optional (in brackets).

### Related Context
- **Previous Summary:** RLAMBDA1 (initial Marquardt lambda, ~10.0) and RLAMFAC (Marquardt lambda adjustment factor, ~2.0 or -3.0) control lambda adjustments during iterations.  PHIRATSUF (objective function reduction ratio, ~0.3) determines iteration completion; if not met, PHIREDLAM is used.
- **Next Summary:** If LAMFORGIVE is "lamforgive", PEST switches to central derivatives or stops if no lambda produces a successful model run.  Failed parameter sets are saved in ###error.par files. DERFORGIVE ("derforgive" or "noderforgive") handles derivative calculation failures; "derforgive" sets derivatives to zero and reports missing files.

### Metadata
- **Keywords:** JACUPDATE, LAMFORGIVE, NUMLAM, PHIRATSUF, PHIREDLAM, RLAMBDA1, RLAMFAC, lambdas
- **Chunk ID:** 2995daaa6e7c
- **Chunk Index:** 2
- **Previous Chunk ID:** 9b975b5255bb
- **Next Chunk ID:** 9173261c3d0a

---

## Context

### Summary
**Variables RLAMBDA1, RLAMFAC, PHIRATSUF, PHIREDLAM, and NUMLAM on line five control Marquardt lambda selection in PEST (not used by PEST++). For PESTCHEK compatibility, set them to 10.0, -2.0, 0.3, 0.01, and 10, respectively.**

### Header
**4.6.6 Fifth Line**

### Content
The fifth line of the “control data” section of a PEST control file contains variables which control the way in which PEST selects a Marquardt lambda. Programs of the PEST++ suite which employ a Marquardt lambda do not read this line because they use their own lambda control variables. For PESTCHEK-friendliness, set RLAMBDA1, RLAMFAC, PHIRATSUF, PHIREDLAM and NUMLAM to 10.0, -2.0, 0.3, 0.01 and 10 respectively.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 4. The PEST Control File
- **Subsection:** 4.6 Control Data Section

### Additional Summaries
- **Higher-Level Summary:** Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.
- **Detailed Summary:** The optional "automatic user intervention" section (section 6.3) governs automatic user intervention, activated by setting DOAUI to "doaui" in the "control data" section.  If omitted, default values are used.

### Related Context
- **Previous Summary:** NTPFLE and NINSFLE (integers >1) specify template and instruction file counts.  PRECIS ("single") and DPOINT ("point") control parameter value formatting (not used by PEST++). NUMCOM (integer, 1 or omitted for single command lines) specifies the number of model command lines.  These variables are used by PEST but not PEST++.
- **Next Summary:** RELPARMAX, FACPARMAX (≥1.0), and FACORIG (often 0.001) in the "control data" section limit parameter changes per iteration in PESTPP-GLM to prevent overshooting and oscillations.  RELPARMAX < 1.0 is allowed only if bounds are not of opposite sign.  Default values of 10.0 are often suitable.

### Metadata
- **Keywords:** NUMLAM, PHIRATSUF, PHIREDLAM, RLAMBDA1, RLAMFAC
- **Chunk ID:** a02a8be1a203
- **Chunk Index:** 1
- **Previous Chunk ID:** 9813ada0b4b7
- **Next Chunk ID:** b8af6e056ac6

---

## Context

### Summary
**INITSCHFAC (0.2-0.3) sets the initial line search point. MULSCHFAC (1.3-1.7) adjusts the search distance.  PD1 should be ~0.2% higher than PD0 for line searches.  Tight ABSPREDSTP and RELPREDSTP values are recommended.  Lower RLAMBDA1 or set NUMLAM=1 to reduce line searches.  RELPREDSWH (~0.05) and ABSPREDSWH control switching to higher-order derivatives when the objective function is below PD1.  NPREDNORED limits iterations without prediction improvement.**

### Header
**8.3.2 Predictive Analysis Section of the PEST Control File**

### Content
When undertaking the line search, the initial model run is undertaken at that point along the parameter upgrade vector which is a factor of INITSCHFAC along the line of the distance that PEST would have chosen using the theory presented in Doherty (2015) alone. It has been found from experience that if complexities of model behaviour dictate that a line search is necessary, then it is worth doing it properly. So unless there is a good reason to do otherwise, a value of 0.2 to 0.3 is appropriate here; thus the line search begins at a point on the potential parameter upgrade line which is not too far from current parameter values. This accommodates the sometimes complex nature of the line search, where PEST must monitor both the value of the prediction and of the objective function. It is far from uncommon for variation of the prediction to be monotonic along the direction of the line search while the objective function may fall and then rise in this same direction.
In undertaking the line search, PEST moves along the parameter upgrade vector, increasing or decreasing the distance along this vector by a factor of MULSCHFAC as appropriate. A value of 1.3 to 1.7 is suitable for this variable in most cases. Then, once the min+ contour has been subtended by two different model runs, PEST uses a bisection algorithm to find the intersection point with greater precision.
As stated above, when undertaking a line search, set PD1 0.2 percent (or less) higher than PD0. It is also a good idea to implement the following strategies.
- Set ABSPREDSTP and RELPREDSTP reasonably tight. As is discussed below, these are actually the termination criteria for the predictive analysis process. However one tenth of these values constitute termination criteria for the line search.
- Start the predictive analysis process from optimised parameter values (for which the
objective function is less than PD0). Because the line search is repeated for every different value of the Marquardt lambda tested, it can consume an inordinate number of model runs if significant Marquardt lambda adjustment is warranted. Code has been inserted within PEST that aims to reduce the number of line search runs required when testing Marquardt lambdas after the first during any one optimisation iteration. Nevertheless, any savings that can be made in reducing trial Marquardt lambdas will result in increased efficiency. Thus after you have had experience with using the predictive analyser on your particular task, you may wish to consider setting the initial Marquardt lambda (RLAMBDA1) lower or higher than you normally would, if this is where PEST seems to prefer its value to be. Alternatively, set NUMLAM to 1, so that only 1 Marquardt lambda is employed per optimisation iteration; if this strategy is adopted it is probably good practice to try a very low value for RLAMBDA1, maybe in the vicinity of 0.01 to 0.001 (or even zero).
While conducting a line search is a very time-consuming activity, experience has shown that it can be worth the effort in many circumstances; it is sometimes quite surprising how high or low calibration-constrained predictions can be. The cost of finding these extreme predictions, however, can be particularly harsh when using Parallel PEST or BEOPEST to undertake the predictive analysis process, because while Jacobian runs are parallelised, line search runs are not (because a line search is an innately serial process).
ABSPREDSWH and RELPREDSWH
In the “parameter groups” section of the PEST control file, the user informs PEST whether derivatives of model outcomes with respect to the members of each parameter group are to be calculated using two points, three points, five points, or two points at first and then three or five points later. When run in “estimation” mode, PEST makes the switch between two point and higher order derivatives calculation if it fails to lower the objective function by a relative amount equal to PHIREDSWH between successive iterations. The value for PHIREDSWH is supplied in the “control data” section of the PEST control file.
When used in “predictive analysis” mode, the role of PHIREDSWH is unchanged if the current objective function is above PD1. However if it is below PD1, PEST’s decision to switch from two point derivatives calculation to higher order derivatives calculation is based on improvements to the model prediction. If, between two successive optimisation iterations, the model prediction is raised (lowered) by no more than a relative amount of RELPREDSWH or by an absolute amount of ABSPREPSWH, PEST makes the switch to higher order derivatives calculation. A setting of 0.05 is often appropriate for RELPREDSWH. The setting for ABSPREDSWH is context-dependent. Supply a value of 0.0 for either of these variables if you wish that it has no effect on the optimisation process. (On most occasions ABSPREDSWH should be set to 0.0.)
NPREDNORED

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 8. Predictive Analysis
- **Subsection:** 8.3 Predictive Analysis Control Variables

### Additional Summaries
- **Higher-Level Summary:** In "predictive analysis" mode, PEST optimizes predictions while maintaining the objective function below a threshold, considering post-calibration uncertainty. It requires accurate derivatives, a prior calibration process, and parameter consistency with the estimation run. Users can adjust Marquardt lambda, search parameters, and incorporate predictive noise for improved analysis.
- **Detailed Summary:** To run PEST in "predictive analysis" mode, set PESTMODE to "prediction", define observation groups, and perform a prior "estimation" run. Adjust Marquardt lambda iteratively to maximize/minimize predictions while meeting objective function criteria. Use line search, adjust search parameters, and set termination conditions based on prediction improvement. User intervention can modify line search variables.

### Related Context
- **Previous Summary:** In "predictive analysis" mode, PEST iteratively adjusts Marquardt lambda to maximize/minimize a prediction while maintaining the objective function ≤ PD1.  If Φ ≤ PD1, it prioritizes prediction adjustment; otherwise, it prioritizes objective function reduction.  It stops testing lambdas when the relative reduction in the objective function or (Φ - PD0) is ≤ PHIREDLAM or when the relative (RELPREDLAM) or absolute (ABSPREDLAM) prediction change is insufficient.  A line search (NSEARCH) may refine the prediction.
- **Next Summary:** NPREDNORED (integer, ~4) iterations without prediction improvement triggers termination in "predictive analysis" mode.  ABSPREDSTP (real, context-dependent) and RELPREDSTP (real, ~0.005) define thresholds for prediction convergence (NPREDSTP highest/lowest predictions).  NOPTMAX sets the maximum number of iterations. User intervention (section 6.2) can adjust line search control variables.

### Metadata
- **Keywords:** ABSPREDSTP, ABSPREDSWH, INITSCHFAC, MULSCHFAC, NPREDNORED, NUMLAM, PD0, PD1, PHIREDSWH, RELPREDSTP, RELPREDSWH, RLAMBDA1, lambdas
- **Chunk ID:** e3fcf54872ce
- **Chunk Index:** 3
- **Previous Chunk ID:** 4a1528c1cbae
- **Next Chunk ID:** cbd30e177677

---

## Context

### Summary
**PESTPP-PSO (parallel only) uses a PEST control file (Chapter 4) and a PSO control file (specified via "++PSO(case.pso)") for multi-objective optimization (Siade et al. 2019, Coello et al. 2004). PESTPP-GLM starts agents.  PESTPP-PSO uses data from the PEST control file (Figure 11.1, shaded variables) and is compatible with PEST and its utilities.  Dummy values are needed for unused PEST variables.**

### Header
**11.1.1 General**

### Content
PESTPP-PSO was developed using the FORTRAN interface provided within the PEST++ source code. Currently, PESTPP-PSO is only designed to operate in parallel, and the command to execute the “manager” is as follows (which differs slightly from the other PEST++ calling programs),
| pestpp-pso case*.*pst port |
|----------------------------|
where, *case* represents the base name for the modeling study and *port* is the port number over which communications occur (please see previous documentation in this manual on the general usage of PEST++, e.g., Chapter 5). The main control file follows the format of a standard PEST control file (see Chapter 4). The calling program, PESTPP-PSO, will obtain most of the data regarding the optimization problem from this PEST control file. That is, it will collect some control, parameter and observation data; Figure 11.1 displays which data is actually used by PESTPP-PSO (shaded in grey). Some of this differs from most other PEST++ programs. It is important to note that PESTPP-PSO is designed to be compatible with PEST and its utilities (e.g., PESTCHEK). So, even if PESTPP-PSO is not using some of the variables listed in Figure 11.1, a dummy value must be entered in their place; this can be anything the user wants so long as it’s consistent with the format of the variable as defined by PEST (i.e., the dummy value for an integer variable should still be an integer, a character string should be a character string, etc.).
PESTPP-PSO must use another PEST++ calling program to initiate the “agents”. It is recommended that the PESTPP-GLM is used for this with the following command (see Chapter 5 for more details). In addition to the information contained in the main control file, PESTPP-PSO will need additional PSO-specific control variables. These will be contained in a separate PSO control file, which is defined by entering a line in the main control file that provides the path to the PSO specs file, and begins with the “++” identifier, i.e.,
++PSO(*case*.pso)
pcf
* control data
RSTFLE PESTMODE
NPAR NOBS NPARGP NPRIOR NOBSGP
NTPLFLE NINSFLE PRECIS DPOINT
RLAMBDA1 RLAMFAC PHIRATSUF PHIREDLAM NUMLAM
RELPARMAX FACPARMAX FACORIG
PHIREDSWH
NOPTMAX PHIREDSTP NPHISTP NPHINORED RELPARSTP NRELPAR
ICOV ICOR IEIG
* singular value decomposition
SVDMODE
MAXSING EIGTHRESH
EIGWRITE
* parameter groups
PARGPNME INCTYP DERINC DERINCLB FORCEN DERINCMUL DERMTHD
(one such line for each parameter group)
* parameter data
PARNME PARTRANS PARCHGLIM PARVAL1 PARLBND PARUBND PARGP SCALE OFFSET DERCOM
(one such line for each parameter)
PARNME PARTIED
(one such line for each tied parameter)
* observation groups
OBGNME
(one such line for each observation group)
* observation data
OBSNME OBSVAL WEIGHT OBGNME
(one such line for each observation)
* model command line
COMLINE
(one such line for each model command line)
* model input
TEMPFLE INFLE
(one such line for each template file)
* model output
INSFLE OUTFLE
(one such line for each instruction file)
* prior information
PILBL PIFAC * PARNME + PIFAC * log(PARNME) ... = PIVAL WEIGHT OBGNME
(one such line for each article of prior information)
* regularization
PHIMLIM PHIMACCEPT [FRACPHIM]
WFINIT WFMIN WFMAX
WFFAC WFTOL [IREGADJ]
++
++PSO(case.pst)
Figure 11.1. Variables comprising a minimalist PEST control file (see Figure 4.1), where the control variables used by PESTPP-PSO are shaded in grey. Note that the very last line designates the PSO control file.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 11
- **Subsection:** 11.1 Using PESTPP-PSO

### Additional Summaries
- **Higher-Level Summary:** Parallel PEST and BEOPEST parallelize model runs to reduce run time. Parallel PEST needs a run management file, while BEOPEST's is optional. Both distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Parallel PEST uses PAGENT agents, requires separate folders for agents, and shared signal files for communication. BEOPEST offers ease of use, faster communication, flexibility, and support for multiple command lines and surrogate models.
- **Detailed Summary:** Parallel PEST and BEOPEST parallelize model runs, reducing PEST run time. Parallel PEST requires a run management file, while BEOPEST's is optional. They distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Both store data in binary files for reduced memory needs.

### Related Context
- **Previous Summary:** PESTPP-PSO's *eqlog* transforms decision variables, using base 10 for the widest-range variable and scaling others to match its range. This equalizes variability for enhanced PSO performance.  Some variables may be untransformed or have expanded ranges. See *Siade et al*, (2019) for details.
- **Next Summary:** In PESTPP-PSO estimation mode (Figure 11.2),  PSO-specific control variables include RSTPSO (0=new, 1=restart), NOBJGP (always 1), NCON (number of constraints), NFORG (allowed failures), VERBOSE (verbosity level), NPOP (swarm size), C1/C2 (cognitive/social constants, ≤4.0), ISEED (random seed), INITP (0=random, 1=PARVAL1 + random, 2=external file, Section 11.2.3), VMAX (maximum velocity, 0<VMAX≤1), IINERT/FINERT/INITER (inertia parameters).

### Metadata
- **Keywords:** * control data, * model command line, * observation data, * observation groups, * parameter data, * parameter groups, * prior information, * regularization, * singular value decomposition, COMLINE, DERCOM, DERINC, DERINCLB, DERINCMUL, DERMTHD, DPOINT, EIGTHRESH, EIGWRITE, FACORIG, FACPARMAX, FORCEN, FRACPHIM, ICOR, ICOV, IEIG, INCTYP, INFLE, INSFLE, IREGADJ, MAXSING, NINSFLE, NOBS, NOBSGP, NOPTMAX, NPAR, NPARGP, NPHINORED, NPHISTP, NPRIOR, NRELPAR, NTPLFLE, NUMLAM, OBGNME, OBSNME, OBSVAL, OFFSET, OUTFLE, PARCHGLIM, PARGP, PARGPNME, PARLBND, PARNME, PARTIED, PARTRANS, PARUBND, PARVAL1, PESTMODE, PHIMACCEPT, PHIMLIM, PHIRATSUF, PHIREDLAM, PHIREDSTP, PHIREDSWH, PIFAC, PILBL, PIVAL, PRECIS, RELPARMAX, RELPARSTP, RLAMBDA1, RLAMFAC, RSTFLE, SCALE, SVDMODE, TEMPFLE, WFFAC, WFINIT, WFMAX, WFMIN, WFTOL
- **Chunk ID:** e0889828dd60
- **Chunk Index:** 1
- **Previous Chunk ID:** c66ecb1eac1c
- **Next Chunk ID:** 13fe2c26bb4f

---
