# Search Results for: What is NOBS?

Keywords: nobs

## Variations
1. What is NOBS?
2. Explain what NOBS is
3. Describe NOBS
4. Tell me about NOBS
5. Define NOBS


## Context

### Summary
**JCOBLANK creates a file specifying zero-valued Jacobian matrix elements for user-defined localization, improving randomized Jacobian calculations. It optionally creates a simultaneous increment file.  It uses a logical pseudo Jacobian matrix (NOBS rows, NESPAR columns, excluding prior information) where TRUE indicates non-zero elements and FALSE indicates zero elements.**

### Header
**5.19.1 General**

### Content
JCOBLANK writes a file that informs programs such as PEST_HP that certain elements of its Jacobian matrix must be assigned a value of zero. It thus provides a basis for user‑prescribed “localization”. This can upgrade the integrity of randomized Jacobian matrix calculation. It also supports Jacobian matrix calculation through finite parameter differencing in which more than one parameter is incremented during any particular model run.
Simultaneous parameter incrementation becomes a possibility if the set of model outputs that are sensitive to one parameter has no commonality with the set of model outputs that are sensitive to another parameter. Optionally, JCOBLANK devises a model run strategy through which simultaneous parameter increments may be used to fill the Jacobian matrix. This run strategy is recorded in a “simultaneous increment file”.
Internally, JCOBLANK builds and stores a “pseudo Jacobian matrix”. This is a matrix whose elements are all logical variables, and whose values are thus either FALSE or TRUE; FALSE indicates a zero‑valued Jacobian matrix element while TRUE indicates a non‑zero‑valued Jacobian matrix element. This pseudo Jacobian matrix has NOBS rows and NESPAR.
columns, where NOBS is the number of observations featured in a PEST input dataset and NESPAR is the number of adjustable parameters featured in this dataset; these are read from a PEST control file. Note that JCOBLANK will not zero elements of a Jacobian matrix that pertain to prior information equations.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software
- **Main Section:** 5. JCO File Construction and Manipulation
- **Subsection:** 5.19 JCOBLANK

### Additional Summaries
- **Higher-Level Summary:** The text stresses the importance of post-inversion analysis with PEST utility software. It advocates for multiple runs, model revision for poor fits, and subjective evaluation of model-measurement misfit. Regularization, parameter reasonableness, and removal of insensitive parameters are crucial. Tools like EIGPROC, SSSTAT, and GENLINPRED assist in analysis, culminating in a final model run with optimized parameters or manual adjustments.
- **Detailed Summary:** JCOBLANK creates zero-valued Jacobian matrix elements for user-defined localization, enhancing randomized Jacobian calculations. It generates a logical pseudo-Jacobian matrix, using TRUE for non-zero and FALSE for zero elements. JCOBLANK can zero elements based on a zero file, creating a blanking pattern file for PEST_HP to improve parameter incrementation and sensitivity precision.

### Related Context
- **Previous Summary:** JCOZERO sets Jacobian matrix elements to zero, creating jcofile2 from jcofile1, based on a zerofile (Figure 5.3).  Zerofile uses "* parameters" and "* observations" blocks; each line specifies a parameter/observation name or a group (using "*" and "?" wildcards).  Blank lines and comments (#) are ignored. Use `jcozero jcofile1 zerofile jcofile2`.
- **Next Summary:** JCOBLANK zeroes Jacobian matrix elements based on a zero file (Figure 5.4), creating a logical pseudo-Jacobian matrix (FALSE=zero, TRUE=non-zero). The zero file starts with "* start all zero" or "* start all nonzero"; sections ("zero" or "nonzero", parameter/group, observation/group) list elements to zero.  Wildcards (*, ?) allow flexible string matching in the second column.

### Metadata
- **Keywords:** NOBS
- **Chunk ID:** ac0ae42c9d07
- **Chunk Index:** 1
- **Previous Chunk ID:** 18d3ec220551
- **Next Chunk ID:** 2e0ef1f71127

---

## Context

### Summary
**NPAR, NOBS, NPARGP, NPRIOR, and NOBSGP (integers, >0 except NPRIOR which can be 0) specify parameter, observation, and group counts from respective PEST control file sections.  PEST++ programs only use the first variable on this line; however, PESTCHEK requires correct values for all variables.**

### Header
**4.6.4 Third Line **

### Content
Although programs of the PEST++ suite read only the first variable on this line, the other variables that are featured on this line in figure 4.3 must be set to correct values to pass the scrutiny of PESTCHEK. All of these variables are integers. Their values must be greater than zero, except for NPRIOR which can be zero.
NPAR is the number of parameters featured in the “parameter data” section of a PEST control file. NOBS is the number of observations featured in the “observation data” section of a PEST control file. NPARGP is the number of parameter groups featured in the “parameter groups” section, while NPRIOR is the number of prior information equations featured in the “prior information” section of a PEST control file. The final variable on this line (NOBSGP) is the number of observation groups featured in the “observation groups” section of a PEST control file.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 4. The PEST Control File
- **Subsection:** 4.6 Control Data Section

### Additional Summaries
- **Higher-Level Summary:** Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.
- **Detailed Summary:** The optional "automatic user intervention" section (section 6.3) governs automatic user intervention, activated by setting DOAUI to "doaui" in the "control data" section.  If omitted, default values are used.

### Related Context
- **Previous Summary:** RSTFLE ("restart") enables PEST's restart capability. PESTMODE ("estimation" or "regularization") sets the operational mode;  "regularization" mode uses the "regularization" section (or defaults if absent).
- **Next Summary:** NTPFLE and NINSFLE (integers >1) specify template and instruction file counts.  PRECIS ("single") and DPOINT ("point") control parameter value formatting (not used by PEST++). NUMCOM (integer, 1 or omitted for single command lines) specifies the number of model command lines.  These variables are used by PEST but not PEST++.

### Metadata
- **Keywords:** NOBS, NOBSGP, NPAR, NPARGP, NPRIOR
- **Chunk ID:** 255d2e8af039
- **Chunk Index:** 1
- **Previous Chunk ID:** 07ced7dc7c05
- **Next Chunk ID:** 9813ada0b4b7

---

## Context

### Summary
**SCREENDISP ("noverbose" or "verbose") controls TEMPCHEK and INSCHEK screen output. NPAR matches the number of parameters in template and parameter variation files. NOBS matches the number of observations in instruction files. NTPFLE is the number of template files; NINSFLE is the number of instruction files. PRECIS ("single" or "double") sets numerical precision (single usually suffices).**

### Header
**17.2.6 Control Data Section**

### Content
SCREENDISP
SCREENDISP is a character variable which can take either one of two possible values. These values are “noverbose” and “verbose”. In the former case, when SENSAN runs TEMPCHEK and INSCHEK it redirects all of the screen output from these programs to the null file; hence the user is not aware that they are running. In the latter case, TEMPCHEK and INSCHEK output is directed to the screen in the usual fashion.
Once you have set up a SENSAN run and ensured that everything is working correctly, a nicer screen display is obtained by using the “noverbose” option. In this case you should ensure that the model likewise produces no screen output by redirecting its output to the null file using, for example, the command
model > nul
to run the model. For a UNIX system this command becomes
model > /dev/null
If SENSAN is thus left to produce the only screen output, you can monitor its progress and detect any SENSAN error messages if they are written to the screen.
NPAR
This is the number of parameters. It must agree with the number of parameters cited in the template file(s) used by SENSAN. It must also agree with the number of parameters named in the parameter variation file provided to SENSAN.
NOBS
NOBS is the number of “observations”, i.e. the number of model outcomes used in the sensitivity analysis process. It must agree with the number of observations cited in the instruction file(s) provided to SENSAN.
NTPFLE
NTPFLE is the number of template files to be used by SENSAN. For each template file there must be a corresponding model input file; see below. Note that a given template file can be used to write more than one model input file; however two templates cannot write the same model input file.
NINSFLE
NINSFLE is the number of instruction files used by SENSAN to read model outcomes. For each instruction file there must be a matching model output file. Note that the same instruction file cannot read more than one model output file (observation values would be overwritten); however two different instruction files can read the same model output file.
PRECIS
PRECIS is a character variable which must take either the value “single” or “double”. It determines whether single or double precision protocol is used to represent a very large or very small number, or a number in a wide parameter space; see section 2.2.6 for more details. The value “single” is usually appropriate.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 17. SENSAN (continuación)
- **Subsection:** 17.2 SENSAN File Requirements (continuación)

### Additional Summaries
- **Higher-Level Summary:** SENSAN uses control, parameter variation, and PEST template and instruction files. It runs system commands post-model runs, with options for OS commands or executables. PEST templates generate model inputs, instructions read outputs. Run with `sensan infile`, using tempchek.exe and inschek.exe. Outputs include ABSFLE, RELFLE, SENSFLE. SENSCHEK checks input data.
- **Detailed Summary:** SENSAN utilizes a control file, parameter variation file, and PEST template and instruction files. It executes system commands after model runs, with options for operating system commands or executables. PEST template files are used to generate model input files, and instruction files are employed to read model outputs.

### Related Context
- **Previous Summary:** The SENSAN control file (Figure 17.2, recommended ".sns" extension) starts with "scf", contains sections marked by "*", and uses many PEST variables. It includes control data, SENSAN files (parameter variation file, base output file, relative output file, sensitivity file), model command line, and model input/output (template and instruction files, Figure 17.3).
- **Next Summary:** VARFLE names the parameter variation file (must match NPAR).  ABSFLE, RELFLE, and SENSFLE name SENSAN's output files (contents described below).

### Metadata
- **Keywords:** NINSFLE, NOBS, NPAR, PRECIS
- **Chunk ID:** 6592c97ef380
- **Chunk Index:** 1
- **Previous Chunk ID:** e87ee1e03ea0
- **Next Chunk ID:** c13ba89f9f8d

---

## Context

### Summary
**DSI (data space inversion) conditions a prediction's uncertainty using model outputs from runs with prior parameter samples (Doherty 2015, Sun and Durlofsky 2017).  It calculates posterior prediction mean (μ₁′, Equation 18.1.4) and variance (C₁₁′, Equation 18.1.5) using  calibration data (x₂). C₂₂⁻¹ is approximated via SVD (Equation 18.1.7) of a NREAL x NREAL matrix (NREAL=number of model runs, usually <NOBS).  DSI2 offers more comprehensive analysis.**

### Header
**18.1.1 Theory**

### Content
Note: See documentation for DSI2 before using DSI or DSI1. In general, DSI2 is the best option for data space inversion. However some of the theory behind data space inversion is explained in documentation for DSI and DSI1.
18.1.1.1 General
“DSI” stands for “data space inversion”. The purpose of the DSI utility is to undertake history matching without actually estimating parameters. It is able to condition (and thereby reduce the uncertainty of) a user‑specified prediction from its uncertainty calculated on the basis of the prior parameter probability distribution. It accomplishes this using the outcomes of a suite of model runs which span both the calibration and prediction periods. When undertaking these runs, the model employs parameters which are sampled from the prior parameter probability distribution.
18.1.1.2 Conditioning
The theory behind data space inversion, as undertaken by DSI, is now briefly explained. Part of the following explanation is extracted from Doherty (2015). For an alternative methodology and explanation of the theory, see Sun and Durlofsky (2017).
The DSI program that is described herein implements a quick and approximate version of the Sun and Durlofsky methodology. More comprehensive DSI‑type analysis is available from DSI2.
Let x be a random vector. Suppose that we partition x into the vectors x1 and x2 as follows:
x = x2   x1                                                                                       (18.1.1)
Let the mean of x be denoted as
μ = μ2   μ1                                                                                       (18.1.2)
The prior covariance matrix C(x) of x can be partitioned according to the partitioning of x into x1 and x2 as
C( )= C21x C11    C12
C22                                                                             (18.1.3)
If variability of x is described by a multinormal distribution, then the marginal distribution of x1 is completely characterized by μ1 and C11. Suppose now that we acquire perfect knowledge of values taken by elements of the x2 vector. This modifies the probability distribution of x1. Let μ1′ and C′11 specify the mean and covariance matrix of this modified distribution (i.e. the posterior mean and covariance matrix of x1). It can be shown (see, for example, Koch, 1999) that
μ′ = μ1 + C12C‑122 (x2 – μ2) (18.1.4)
and that:
C′11 = C11 – C12C‑122C21 (18.1.5)
For the DSI program described herein, the x1 vector has just one component, namely a prediction of interest. Meanwhile x2 is comprised of measurements which collectively constitute a calibration dataset. That is, it is comprised of calibration‑equivalent model outputs to which measurement noise has been added. The covariance matrix C22 which describes the prior variability of these outputs is obtained empirically by running the model a user‑specified number of times using parameter sets which are sampled from the prior parameter probability distribution; a random realization of measurement noise is added to each such model output. The prior mean model output vector µ2 is calculated from these model outputs, as are the mean µ1 and prior uncertainty variance C11 of the model prediction of interest. The values of measurements comprising the calibration dataset (i.e. the elements of x2) are supplied by the user. DSI uses equation 18.1.4 to calculate the posterior expected value μ1′ of the prediction which comprises the single element of x1. It uses equation 18.1.5 to calculate the posterior variance of this prediction, this comprising the single element of the matrix C′11.
As mentioned above, DSI fills the C22 and C12 matrices which appear in the above equations by undertaking model runs based on an ensemble of random realizations of parameters sampled from the prior parameter probability distribution. There is no limit to the number of parameters which the model can employ, for parameters are not featured in the above equations. Model output variances and covariances are calculated from the ensemble of model outputs using standard formulae for calculation of variance and covariance (possibly after transformation to enhance multinormality of these outputs).
18.1.1.3 Obtaining the inverse of C22
Where observations comprising a calibration dataset outnumber realizations used for covariance calculation (as is usually the case), the C22 matrix is not of full rank. Hence its inverse C‑122 does not exist. An approximation to this inverse can be calculated using truncated singular value decomposition. However where the number of observations is large, the C22 matrix is very large indeed, for its dimensions are NOBS×NOBS where NOBS is the number of non‑zero‑weighted observations featured in a calibration dataset. The computational effort required to calculate an approximation to C‑122 may therefore become prohibitive. DSI overcomes this problem by undertaking singular value decomposition on a matrix whose dimensions are NREAL×NREAL rather than NOBS×NOBS, where NREAL is the number of realizations of parameters (i.e. the number of model runs) used to compute C22; as already stated, this is normally far less than the number of observations comprising a calibration dataset. The way in which DSI accomplishes this task is now described.
If C22 is subjected to singular value decomposition, we obtain C22 = US2Ut (18.1.6) (S is squared in the above equation because of its relationship to a matrix that will be discussed below.) A generalized inverse of C22 is then obtained as C‑122 = US‑2Ut (18.1.7) When using equation 18.1.7 to construct C‑122, truncation takes place where singular values are zero or near‑zero; this cannot exceed the number of realizations used for prediction.
conditioning. Nor can it exceed the number of observations that are used for prediction conditioning.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software
- **Main Section:** 18. Data Space Inversion
- **Subsection:** 18.1 DSI

### Additional Summaries
- **Higher-Level Summary:** The text describes using soil clod shrinkage data to fit two straight lines using Equation 18.1.1 with parameters s1, s2, y1, and xc in the pestex subfolder. The TWOLINE program reads parameters and water contents from in.dat, adjusts parameters using PEST, and generates input files for calculations. The final prediction value is 0.786.
- **Detailed Summary:** The example in the pestex subfolder fits two straight lines to soil clod shrinkage data for residual and normal shrinkage. The model uses Equation 18.1.1 with parameters s1, s2, y1, and xc. Program TWOLINE in the pestex folder reads parameters and water contents from in.dat, calculates specific volumes, and adjusts parameters using PEST to minimize discrepancies with laboratory data.

### Related Context
- **Previous Summary:** RANDOBS generates random model output realizations (CSV or JCB file), prompting for an observation weights file (can be a PEST control file), a weight factor (>0), number of realizations (>0), inclusion of initial observations ("y" or "n"), output filename (.csv or .jcb), row/column orientation ("r" or "c" for CSV files), and random seed.
- **Next Summary:** DSI approximates C₂₂⁻¹ using SVD. Z (Equation 18.1.8) is a matrix of noise-supplemented model outputs; µ₂ᵢ (Equation 18.1.9) is the mean model output. C₂₂ = ZZᵀ. DSI performs SVD on ZᵀZ (Equation 18.1.11, ZᵀZ=VS²Vᵀ), calculating G (Equation 18.1.13, US⁻¹=G) and C₂₂⁻¹=GGᵀ (Equation 18.1.14) with singular value truncation.  This is computationally cheaper than using SVD on C₂₂ directly.

### Metadata
- **Keywords:** NOBS
- **Chunk ID:** d0f1261b8386
- **Chunk Index:** 1
- **Previous Chunk ID:** adcb2d04fb06
- **Next Chunk ID:** 74fe6d90ab7f

---

## Context

### Summary
**PEST accepts ASCII (number of columns, rows;  Figure 12.2) or compressed ASCII (NPAR, NOBS, NDIMCOMP;  Figure 12.3) external derivatives files.  Compressed files list only non-zero elements.  Binary versions (with NDIMCOMP, 4-byte integers, 8-byte doubles) are also supported.  PEST deletes existing files before running the model; errors indicate model failure or file writing issues.**

### Header
**12.4.3 File Formats**

### Content
ASCII Uncompressed
The external derivatives file can be an ASCII (i.e. text) file in which numbers are separated by spaces, tabs or a comma (it is read by PEST using free field input). This file must be headed by a line containing two integers. These are the number of columns and rows comprising the following matrix. These numbers must be NPAR and NOBS respectively where NPAR is the number of parameters and NOBS is the number of observations cited in the PEST control file for the current case. The ordering of parameters and observations in the external derivatives file must be the same as that in the PEST control file. Note that a column must be included in the derivatives matrix for every parameter, even for those parameters which are tied or fixed (PEST ignores derivatives calculated with respect to fixed parameters). Similarly, there must be a row for every observation cited in the PEST control file, even for observations which are assigned a weight of zero.
Where there are many parameters to be estimated, each row representing the derivatives of a particular observation with respect to all parameters can be wrapped onto the next line (or as many lines as you wish). However derivatives for the next observation must begin on a new line.
Figure 12.2 shows an example of an uncompressed ASCII external derivatives file.
|4|9| | |
|---|---|---|---|
|5.00000|1707.60|34.4932|42.1234|
|5.25066|8.79458|93.2321|23.5921|
|1.04819|1.16448|5.34642|19.3235|
|1.52323|0.11418|0.59235|75.2354|
|3.21342|0.48392|9.49293|95.3459|
|2.49321|5.39230|0.49332|9.22934|
|19.4492|9.93024|0.49304|5.39234|
|36.3444|10.4933|0.59439|6.49345|
|95.4592|86.4234|47.4232|324.434|
Figure 12.2 An uncompressed ASCII external derivatives file.
ASCII Compressed
PEST provides an option for supplying the external derivatives file in a more compressed format than that illustrated in figure 12.2. This format is depicted in figure 12.3.
NPAR NOBS NDIMCOMP
IPAR1 IOBS1 DERIV(IOBS1,IPAR1)
IPAR2 IOBS2 DERIV(IOBS2,IPAR2)
..
ndimcomp times
Figure 12.3 Format for a compressed ASCII external derivatives file.
The first line of a compressed external derivatives file should contain three integers, namely NPAR and NOBS (same as for the uncompressed alternative), and another entry named NDIMCOMP. NDIMCOMP must be set to 0, or to a positive number equal to the number of entries to follow. If it is set to 0 (or omitted), the following Jacobian matrix is assumed to adopt the protocol depicted in figure 12.2. If it is set to a positive number, it informs PEST
that NDIMCOMP lines of data follow in this file. Each of the following lines must contain three entries. The first two entries (IPAR and IOBS) are integers whereas the third ((DERIV(IOBS,IPAR)) is a real number (which can be double precision if desired). IPAR is the parameter number, while IOBS is the observation number; DERIV(IOBS, IPAR) is the element of the derivatives matrix corresponding to observation IOBS and parameter IPAR. Only non-zero elements of the derivatives matrix need to be supplied; missing elements are assumed to be zero.
Compressed storage of an externally-supplied derivatives matrix can result in a dramatic reduction in the size of the external derivatives file where a large number of nonlinear (and hence model-calculated) regularisation constraints are used in the inversion process, for under these circumstances, the derivatives matrix normally has many zero-valued elements.
Binary Compressed and Uncompressed
Binary versions of the compressed and uncompressed external derivatives files described above can be read by PEST. However the following should be noted if supplying these types of file to PEST.
- Optional variables cannot be supplied in binary files. Hence, irrespective of whether a full or compressed matrix is provided, the NDIMCOMP variable must be supplied in the header to a binary external derivatives file. If NDIMCOMP is set to zero, PEST takes this as a signal that the full matrix follows. If it is set to a positive number, this indicates the number of ensuing data lines. If it is supplied as a negative number, PEST ceases execution with an error message.
- Integer values are expected as four byte numbers. However NCOMPDIM is expected to be of eight bytes length if an INTEL compiled version of PEST is employed. (This accommodates very large derivative matrices.)
- Matrix elements are expected as double precision (eight bytes) real numbers.
File Management
If you notify PEST that the model will supply an external derivatives file, then you must also inform PEST of the name of this file, the protocol that it adopts for storage of matrix elements, and of the command which PEST must use to run the model in such a way that it writes this file. (The mechanism for accomplishing all of these is discussed below.) Just before issuing this command (it is issued once for every iteration of the inversion process) PEST first checks to see whether a derivatives file already exists. If such a file does exist, PEST deletes it. Thus if the model fails to run, PEST does not read the old file, mistaking it for the new one; instead it writes an error message to the screen informing you that the derivatives file cannot be found. Alternatively, if PEST issues an error message to the effect that it encountered a premature end to the external derivatives file, this indicates that either the model did not run to completion, or that there is an error in the code added to the model to write this file.
Derivatives Type

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 12. Model-Calculated Derivatives (continuación)
- **Subsection:** 12.4 Externally-Supplied Derivatives

### Additional Summaries
- **Higher-Level Summary:** PEST uses pest.mmf to send messages before each run, indicating run type and parameter details. Different commands can be used for regular and derivative-calculating model runs, potentially reducing run time. Models can provide PEST with derivatives more efficiently, supporting various file formats. PEST control file variables manage model commands, messaging, and external derivatives.
- **Detailed Summary:** Models can provide PEST with derivatives more efficiently than PEST's finite difference method. PEST can utilize these model-calculated derivatives via specially formatted external files, supporting ASCII, compressed ASCII, and binary formats. Models must be modified to create these files, which differ from PEST's Jacobian matrix and do not consider parameter transformations.

### Related Context
- **Previous Summary:** A model can provide PEST with derivatives via a specially formatted external derivatives file containing a derivatives matrix (rows=observations, columns=parameters).  This matrix differs from PEST's Jacobian matrix; it does not account for parameter transformations.  The model must be modified to create this file.
- **Next Summary:** For log-transformed parameters, the model provides derivatives with respect to untransformed parameters; PEST handles the conversion internally.  Similarly, PEST accounts for SCALE and OFFSET values, so the model need not.

### Metadata
- **Keywords:** NOBS, NPAR
- **Chunk ID:** cd22c15afc22
- **Chunk Index:** 1
- **Previous Chunk ID:** 423bada632b0
- **Next Chunk ID:** fd8dcba7c21b

---
