# Search Results for: What is PESTMODE?

Keywords: pestmode

## Variations
1. What is PESTMODE?
2. Explain what PESTMODE is
3. Describe PESTMODE
4. Tell me about PESTMODE
5. Define PESTMODE


## Context

### Summary
**To run PEST in "predictive analysis" mode, set PESTMODE to "prediction", add a "predictive analysis" section (after "prior information"), define at least two observation groups (one named "predict" with only one member), and ensure a prior "estimation" run has been performed.**

### Header
**8.3.1 The PESTMODE Variable**

### Content
For PEST to run in “predictive analysis” mode the following must happen:
1. The PESTMODE variable in the “control data” section of the PEST control file must be set to “prediction”.
2. A “predictive analysis” section must be placed at the end of the PEST control file. This should be placed after the “prior information” section; if there is no prior information then the “prior information” section of the PEST control file can be omitted or simply left empty.
3. At least two observation groups must be defined, one of which should be named “predict”.
4. This “predict” group must contain only one member.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 8. Predictive Analysis
- **Subsection:** 8.3 Predictive Analysis Control Variables

### Additional Summaries
- **Higher-Level Summary:** In "predictive analysis" mode, PEST optimizes predictions while maintaining the objective function below a threshold, considering post-calibration uncertainty. It requires accurate derivatives, a prior calibration process, and parameter consistency with the estimation run. Users can adjust Marquardt lambda, search parameters, and incorporate predictive noise for improved analysis.
- **Detailed Summary:** To run PEST in "predictive analysis" mode, set PESTMODE to "prediction", define observation groups, and perform a prior "estimation" run. Adjust Marquardt lambda iteratively to maximize/minimize predictions while meeting objective function criteria. Use line search, adjust search parameters, and set termination conditions based on prediction improvement. User intervention can modify line search variables.

### Related Context
- **Previous Summary:** In "predictive analysis" mode, PEST maximizes/minimizes a prediction (in the "predict" group) while keeping the objective function ≤ Φ0 (requires a prior "estimation" run).  It uses the same parameters, transformations, and observations as the estimation run.  Restarting uses `/r`, `/j`, `/d`, or `/s` (parallel runs).  Change limits remain important.  Screen output shows prediction values per iteration.  Results include the optimal prediction and parameter values.
- **Next Summary:** The "predictive analysis" section (Figure 8.1) includes NPREDMAXMIN (1 for maximization, -1 for minimization), PREDNOISE (0 or 1, for prediction interval), PD0 (target objective function value), PD1 (acceptable objective function value), and PD2.  A "predict" group (one observation) is required.  The process requires a prior "estimation" run (Φmin).

### Metadata
- **Keywords:** PESTMODE
- **Chunk ID:** f29919ce4b31
- **Chunk Index:** 1
- **Previous Chunk ID:** b94b8e2d6ccd
- **Next Chunk ID:** b989b64fa0c0

---

## Context

### Summary
**PEST iteratively solves inverse problems in four modes ("estimation", "predictive analysis", "regularisation", "pareto"). Each iteration calculates a Jacobian matrix (parallelizable) and then improves parameter estimates using Marquardt lambda (partially parallelizable).  Nonlinearity, regularization, and derivative corruption are addressed.**

### Header
**3.3.1 General**

### Content
PEST has four modes of operation. On any particular run its mode is designated through the PESTMODE variable appearing in the “control data” section of the PEST control file. These modes are “estimation”, “predictive analysis”, “regularisation” and “pareto”. A brief overview of each of these modes is provided shortly.
Regardless of its current mode, PEST’s behavior is iterative. That is, a similar sequence of calculations is repeated many times. As explained by Doherty (2015), only one iteration would be required if a model was linear; repetition of iterations is required because sensitivities of model outputs to parameters change as the values of parameters change.
Each iteration begins with calculation of a Jacobian matrix. The Jacobian matrix has a column for each adjustable parameter (i.e. each parameter which is neither fixed nor tied to a parent parameter). It has a row for each observation and each item of prior information appearing in the PEST control file. Let Jij denote the element of the Jacobian matrix that occupies its i’th row and j’th column. This element is the partial derivative of the i’th observation with respect to the j’th parameter. If a parameter is log-transformed during the inversion process (see later), then the partial derivative takes this into account.
Calculation of the Jacobian matrix requires at least as many model runs as there are adjustable parameters if elements of this matrix are filled by taking finite parameter differences. Hence this part of each iteration is normally the most numerically intensive part. However it is also the part of each iteration whose numerical burden is most easily lightened through parallelization of model runs, as each model run is independent of every other model run.
Once a Jacobian matrix has been calculated it can be used to calculate an improved set of parameters. However this calculation is normally undertaken using a number of different methods.
values of the so-called Marquardt lambda. Different Marquardt lambdas are tested on a kind of “smart trial and error” basis. This strategy brings with it a number of advantages, these including the following:
- it accommodates nonlinear behaviour of a model’s outputs with respect to its parameters;
- it constitutes a primitive regularisation device;
- it can provide some defense against corruption of finite-difference derivatives incurred by model numerical granularity.
This second part of each iteration is not as immediately parallelizable as the first part of each iteration, especially where parameters hit their bounds. In the latter case PEST actually reformulates the inverse problem by temporarily freezing parameters at their bounds according to certain ordering rules; the advantages of this strategy are explained in section 5.4.2.7 of Doherty (2015). Nevertheless, with some compromises, PEST allows parallelisation of this part of each iteration to the degree requested by the user.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 3. What PEST Does
- **Subsection:** 3.3 Modes of Operation

### Additional Summaries
- **Higher-Level Summary:** This chapter introduces PEST, a tool for solving inverse problems in four modes: "estimation", "predictive analysis", "regularisation", and "pareto". It uses control files with specific sections and options for parameter adjustments, transformations, and derivative calculations. PEST generates Jacobian matrices and offers utilities for file manipulation and sensitivity analysis.
- **Detailed Summary:** PEST is a tool that iteratively solves inverse problems in four modes: "estimation", "predictive analysis", "regularisation", and "pareto". It uses Jacobian matrices and Marquardt lambda for parameter estimation. Different methods are employed based on problem types, with options for uncertainty analysis and parallel processing to reduce computational costs.

### Related Context
- **Previous Summary:** The PEST control file (case.pst) and many PEST-generated files share the same base filename (case).  The run record file is case.rec; the Jacobian matrix file is case.jco. Appendix B lists all PEST-generated files.
- **Next Summary:** In "estimation" mode, PEST uses Gauss-Marquardt-Levenberg, singular value decomposition, or LSQR to solve the inverse problem.  Prior information is treated like observations.  For well-posed problems, PEST calculates a posterior parameter covariance matrix; otherwise, it notes non-invertibility.  Post-calibration uncertainties are also quantifiable using PEST utilities like PREDUNC7.

### Metadata
- **Keywords:** PESTMODE, lambdas
- **Chunk ID:** 6c871bf39138
- **Chunk Index:** 1
- **Previous Chunk ID:** 446d785c3001
- **Next Chunk ID:** 04df6002e78d

---

## Context

### Summary
**In Pareto mode (PESTMODE="pareto"),  assign all observations to one group (PARETO_OBSGROUP) and set initial parameters to achieve a zero expert knowledge objective function.  Use weights inversely proportional to parameter standard deviations or covariance matrices.  Set PARETO_WTFAC_START to 0, PARETO_WTFAC_FIN to 1.5-2.0, NUM_WTFAC_INC to 15-20, NUM_ITER_START to 0, NUM_ITER_GEN to 2, and NUM_ITER_FIN to 2.  Plot case.pod to visualize the Pareto front; case.ppd and case.par.N contain parameter values.  Parallel PEST and BEOPEST are supported;  normal restart functionality applies.**

### Header
**12.8 An Example**

### Content
course, is a futile undertaking); the latter option however adds the zero objective function to the case.pod file which can be useful for plotting the outcomes of PEST’s trajectory of the Pareto front. Meanwhile, PARETO_WTFAC_FIN should be set at a value that hopefully achieves slightly too good a level of model-to-measurement fit. A setting of between 1.0 and 2.0 will presumably achieve this if the above weighting suggestions are followed. Traversal of that portion of the Pareto front so defined will then provide parameter sets from which you can choose one that you consider to provide optimal tradeoff between parameter field credibility on the one hand and goodness of model-to-measurement fit on the other hand.
13.3.3 Operational Details
The methodology just described can be thought of as a form of computer-assisted manual regularisation. Though computationally costly, it allows the user to establish for him/herself the point at which model-to-measurement fit is best traded off against respect for expert knowledge. The subjective nature of this decision cannot really be avoided. Using PEST in “pareto” mode enhances your ability to exercise your subjectivity to best advantage in making this decision.
To employ Pareto analysis as a means of highly parameterized inversion the following steps should be taken. (Some of these have already been discussed but will be set out again in order to provide a summary of the methodology.)
1. All observations comprising the measurement dataset should be assigned to a single observation group. To the best of your ability, ensure that relativity of weighting between components of this overall group is correct. In some cases this can be achieved by equalizing contributions to the total measurement objective function by different observation groups before combining them into a single group. Also, weights assigned to members of this group should be such that, as far as you can judge, the contribution to the overall objective function made by observations and prior information equations which express expert knowledge on the one hand, and by field measurements comprising the calibration dataset on the other hand, will be about equal at that point on the Pareto front that is considered to be optimal.
2. Parameters should be given initial values which result in a value of zero for the expert knowledge component of the objective function. Meanwhile, weights assigned to observations and prior information equations which contribute to this expert-knowledge objective function should be the inverse of the expected standard deviations of variability of the parameters which they site. Covariance matrices, perhaps based on variograms, can be used to characterize spatial parameter variability where appropriate.
3. PESTMODE should be set to “pareto”.
4. A “pareto” section should be added to the PEST control file. The name of the observation group pertaining to the calibration dataset should be assigned to the PARETO_OBSGROUP variable. With the weighting strategy suggested above, settings for other Pareto control variables should be as follows:
- 0.0 for PARETO_WTFAC_START
- 1.5 to 2.0 for PARETO_WTFAC_FIN
- 15 to 20 for NUM_WTFAC_INC
- 0 for NUM_ITER_START
- 2 for NUM_ITER_GEN
- 2 for NUM_ITER_FIN
5. Run PEST.
It is important to note that observations and prior information equations that comprise regularisation constraints do not need to belong to an observation group whose name begins with “regul”, as must be the case when PEST is run in “regularisation” mode. However, it is probably a good idea to maintain this protocol for ease of identification of these entities. Also, PEST does not refer to a “measurement objective function” and a “regularisation objective function” when run in “pareto” mode. However you can make this association yourself when allocating names to observation groups used in the Pareto process.
PEST’s behavior when run in “pareto” mode, as well as the screen outputs that it produces and the files which it writes, were described above. At any stage of a PEST run, a picture of the Pareto front (as traversed so far) can be obtained by plotting data contained in file case.pod; parameters corresponding to any point along the Pareto front are available in file case.ppd as well as in file case.par.N, where N signifies the iteration number and case signifies the filename base of the PEST control file.
13.4 Some Further Implementation Details
13.4.1 Parallelisation and Pareto
Both Parallel PEST and BEOPEST can operate in “pareto” mode.
13.4.2 Restarting a Pareto Run
Normal PEST re-start functionality is available when PEST runs in “pareto” mode. There will be many occasions however when a PEST run is finished and a user, on inspection of the outcomes of this run, would like to traverse more of the Pareto front than was traversed during the just-completed run. This can be achieved as follows.
1. Using the PARREP utility, create a new PEST control file containing the last set of parameters that PEST calculated on its previous run. These will correspond to the end of the Pareto front segment as traversed by PEST on its previous run. (Be sure to give the new PEST control file a different name to that of the old PEST control file so that the case.pod, case.ppd and case.par files from the previous run are not overwritten during the new run.)
2. Set PARETO_WTFAC_START to the previous value of PARETO_WTFAC_FIN, and PARETO_WTFAC_FIN to a suitable value. NUM_ITER_START can normally be set to zero to avoid repetition of the last iteration of the previous Pareto process.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 12. Model-Calculated Derivatives (continuación)
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** PEST uses pest.mmf to send messages before each run, indicating run type and parameter details. Different commands can be used for regular and derivative-calculating model runs, potentially reducing run time. Models can provide PEST with derivatives more efficiently, supporting various file formats. PEST control file variables manage model commands, messaging, and external derivatives.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** Calibration seeks a compromise between model fit and parameter reasonableness, informed by the user's concept of system heterogeneity. Pareto mode helps this subjective process by starting with a parameter field where the expert knowledge objective function is zero (e.g., uniform or preferred values with weights inversely proportional to standard deviation or covariance matrices based on variograms).  Measurement data is then gradually introduced by increasing the weight multiplier applied to this group (PARETO_WTFAC_START, often 0, with NUM_ITER_START=0).  The process aims to find an optimal point on the Pareto front (balancing fit and parameter reasonableness).
- **Next Summary:** For SVD-assisted Pareto analysis, perform a standard Pareto run (NOPTMAX=-1 or -2), generate a JCO file, then use SVDAPREP to create a super-parameter control file.  SVDA_MULBPA=1 automatically saves multiple case.bpa.N files.  case.svda.ppd contains base parameter values. SVDA_PAR_EXCL (0, 1, or -1) controls super parameter definition; 1 is recommended for manual regularization.  To reduce parameter variability, use expert knowledge observations as PARETO_OBSGROUP and run from overfit parameters. JCO2JCO adds prior information sensitivities to a JCO file.

### Metadata
- **Keywords:** NUM_ITER_FIN, NUM_ITER_GEN, NUM_ITER_START, PARETO_OBSGROUP, PARETO_WTFAC_FIN, PARETO_WTFAC_START, PESTMODE
- **Chunk ID:** 32d7e046d625
- **Chunk Index:** 8
- **Previous Chunk ID:** e3915464e9be
- **Next Chunk ID:** 27a8375f23d2

---

## Context

### Summary
**To use PEST's "regularisation" mode, set the PESTMODE variable in the "control data" section to "regularisation".**

### Header
**9.2.1 Setting the Mode**

### Content
To run PEST in “regularisation” mode, the variable PESTMODE on the second line of the “control data” section of the PEST control file must be set to “regularisation”.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 9. Tikhonov Regularisation (continuación)
- **Subsection:** 9.2 Regularisation and the PEST Control File

### Additional Summaries
- **Higher-Level Summary:** Tikhonov regularization in PEST enhances stability by reducing error variance and incorporating expert knowledge. Use IREGADJ, SVD, or LSQR with MAXSING and EIGTHRESH settings for stability. PEST stops after NOPTMAX iterations, reaching target objectives, minimal parameter changes, or slow improvement. Regularization mode categorizes observations into "regul" groups, adjusting weights with a regularization weight factor.
- **Detailed Summary:** To use PEST's "regularisation" mode, set PESTMODE to "regularisation" in the control data section. This mode categorizes observations into "regul" groups and others. Regularization weights are adjusted by the regularization weight factor. Key variables in the "regularisation" section include PHIMLIM, PHIMACCEPT, WFINIT, and others. PEST aims to minimize the regularization objective function while iterating until PHIMLIM is reached. Adjusting PHIMACCEPT, FRACPHIM, and other parameters influences optimization.

### Related Context
- **Previous Summary:** In "regularisation" mode, PEST stops if NOPTMAX iterations elapse, the measurement objective function reaches the target (PHIMLIM, REGCONTINUE="nocontinue"), PHISTOPTHRESH is reached, parameter changes are minimal (RELPARSTP, NRELPAR), or objective function improvement is slow (PHIREDSTP, NPHISTP, NPHINORED, REGCONTINUE="continue").  User termination is often preferable, especially during early calibration attempts.
- **Next Summary:** In "regularisation" mode, observations/prior information belong to at least two groups:  "regul" groups (regularization observations) and others (measurement observations).  Regularization weights/covariance matrices are multiplied/divided by the regularization weight factor before objective function calculation.

### Metadata
- **Keywords:** PESTMODE
- **Chunk ID:** 213e5751269f
- **Chunk Index:** 1
- **Previous Chunk ID:** 1720c041e020
- **Next Chunk ID:** 774982993b67

---

## Context

### Summary
**The optional "regularization" section (Doherty 2015) is used when PESTMODE="regularization"; otherwise, it's ignored. PESTPP-GLM uses default values if the section is absent.  PHIMLIM sets the target measurement objective function; PHIMACCEPT (2-5% > PHIMLIM) sets the acceptable level. FRACPHIM (0.0-1.0, recommended 0.1) adjusts PHIMLIM per iteration. WFINIT sets the initial regularization weight factor.**

### Header
**4.16 Regularization Section**

### Content
The regularization section of a PEST control file is optional. If PESTMODE is not set to “regularization”, it is redundant. If it is set to “regularization” and a “regularization” section is not provided, the PESTPP-GLM program (the only program of the PEST++ suite which uses this section) provides default values for the control variables that are featured in it. These variables are now described. To clarify the meanings of some of the terms that appear in the following explanation, see the description of PESTPP-GLM in chapter 6 of this manual. For more general information on regularization, see Doherty (2015).
**PHIMLIM**
PHILIM is the target measurement objective function; it is the measurement objective function that PESTPP-GLM “aims for” while keeping the regularization objective function as low as possible. During every iteration of the inversion process, PESTPP-GLM calculates a regularization weight factor that attempts to achieves this balance.
If you do not know how good a fit can be achieved between model outputs and the calibration dataset, set PHIMLIM very low (for example 1.0E-10) just to see how good a fit you can get between model outputs and field measurements. Meanwhile, the FRACPHIM control variable (see below) can be set to a value such as 0.1; this prevents regularization constraints on parameter values from being totally ignored on the way to achieving the best possible fit with the data. If it turns out that the fit between model outcomes and the calibration dataset is poor, this may indicate that the model needs refinement; by seeking the best possible fit with the calibration dataset you get to find this out early in the calibration process. However, if the fit is good, then PHIMLIM can be set to a value 5 percent to 10 percent higher than the best measurement objective function attained during this PESTPP-GLM run, before running PESTPP-GLM again. Parameter values achieved during the next PESTPP-GLM run should be far more pleasing than those achieved during the first run; it is normally in achieving the last 5 percent to 10 percent reduction in the measurement objective function that parameters are assigned values that violate sensibility constraints as over-fitting occurs.
**PHIMACCEPT**
During PHIMACCEPT each iteration, just after it has linearized the inverse problem through calculating the Jacobian matrix, and just before it begins calculation of the parameter upgrade vector, PESTPP-GLM calculates the optimal value of the regularization weight factor for that iteration. This is the value which, under the linearity assumption encapsulated in the Jacobian matrix, results in a parameter upgrade vector for which the measurement objective function is equal to PHIMLIM. However, due to the approximate nature of the linearity assumption, PESTPP-GLM may not be able to lower the measurement objective function to PHIMLIM in spite of the fact that it uses a number of different values for the Marquardt lambda in attempting to do so. If it cannot lower the measurement objective function to an acceptable level, it simply accepts the upgraded parameters, proceeds to the next iteration and tries again. However, if it does succeed in lowering PHIMLIM to an acceptable level, or if it has succeeded in doing this on previous iterations, then PESTPP-GLM slightly alters its philosophy of choosing new Marquardt lambdas, in that it now attempts to lower the regularization objective function while maintaining the measurement objective below this acceptable level. This acceptable level is PHIMACCEPT; it should be set slightly higher than PHIMLIM in order to give PESTPP-GLM some “room to move” in its attempts to lower the regularization objective function while keeping the measurement objective function below, or close to, PHIMLIM. It needs this “room to move” because of the fact that it bases its calculations on a linearity assumption that is only approximately satisfied.
Normally PHIMACCEPT should be set between 2 percent and 5 percent greater than PHIMLIM.
**FRACPHIM**
The FRACPHIM variable allows you to set PHIMLIM very low (possibly lower than is achievable), but still retain the benefits of regularization.
If FRACPHIM is provided with a value of zero or less (or if this variable is omitted from the PEST control file), then it has no effect on the inversion process. However, if FRACPHIM is provided with a value of between 0.0 and 1.0 (values of 1.0 or greater are illegal), then PESTPP-GLM calculates a new value for PHIMLIM at the beginning of each iteration of the inversion process. This value is calculated as the current value of the measurement objective function times FRACPHIM, or the user-supplied value of PHIMLIM, whichever is higher. Thus, PESTPP-GLM always “aims for” a measurement objective function that is lower than the current one. However, it does not pursue a target that is so low as to require the complete abandonment of regularization.
As well as adjusting the value of PHIMLIM during every iteration, PESTPP-GLM also adjusts the value of PHIMACCEPT. This adjustment is made such that, during every iteration, the ratio of PHIMACCEPT to PHIMLIM is the same as that supplied in the PEST control file.
The recommended value for FRACPHIM is 0.1.
**WFINIT**

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 4. The PEST Control File
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** Prior information lines (Figure 4.11) include PILBL, a linear equation (PIFAC*PARNME or PIFAC*log(PARNME)), PIVAL (real), WEIGHT (real, ≥0), and OBGNME (≤200 characters in PEST++, ≤12 in PEST). Equations must be unique; use "&" for line breaks between items (not within items).  Prior information equations must be assigned to observation groups.
- **Next Summary:** WFINIT (real, use known value or 1.0) sets the initial regularization weight factor. WFMIN/WFMAX (real, e.g., 1E-10/1E10) set limits; exceeding them indicates issues. WFFAC (real, >1.0, ~1.3) controls iterative weight factor adjustment (using Newton's method, stopping when the difference between iterations is ≤WFTOL, real, ~1E-3-1E-2). IREGADJ (0 or 1) controls relative weighting adjustments between regularization groups (section 6.2.3).

### Metadata
- **Keywords:** FRACPHIM, PESTMODE, PHIMACCEPT, PHIMLIM, WFINIT, lambdas
- **Chunk ID:** 88b1e5aa73f5
- **Chunk Index:** 1
- **Previous Chunk ID:** 6663a9a02eca
- **Next Chunk ID:** 747caa196f2f

---
