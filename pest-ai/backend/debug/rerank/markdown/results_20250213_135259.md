# Search Results for: ¿cómo se forma un ensamble de pest?

Keywords: None

## Variations
1. ¿cómo se forma un ensamble de pest?
2. explique cómo se forma un ensamble de pest
3. descríbame el proceso de formación de un ensamble de pest
4. detálleme cómo se forma un ensamble de pest
5. cuénteme cómo se crea un ensamble de pest


## Context

### Summary
**Ensemble methods sample posterior parameter distributions, crucial for decision support.  They require fewer model runs than finite differences for Jacobian matrix creation and allow for less precise model outputs.  Ensemble methods reduce the chance of local minima.  However, they may not achieve the same calibration fit as finite differences and may introduce bias; increasing ensemble size mitigates these issues.  Model run failures may also occur.**

### Header
**9.1.4 Some Repercussions of Using Ensembles**

### Content
The most obvious advantage of using ensembles is their ability to sample the posterior parameter probability distribution. This is critical to a model’s support for environmental decision-making.
There are a number of numerical advantages as well. While partial derivatives calculated using model runs based on random parameters are only approximate, they are often good enough to support a parameter ensemble adjustment process that achieves a good fit between model outcomes and field measurements. Furthermore, because the number of parameter fields that comprises an ensemble need only be as great as the dimensionality of the inverse problem solution space, the number of model runs required to obtain a useable Jacobian matrix to serve as the Z matrix in equations similar to 6.3 can be far fewer than the number of parameters that actually feature in the ensembles. In contrast, when using finite parameter differences to fill a Jacobian matrix, the number of required model runs is equal to the number of parameters.
Another advantage that accrues from use of a randomized Jacobian matrix in place of a finite-difference Jacobian matrix is that the Jacobian-filling process does not require that model outputs have the same numerical precision as that which is required for calculation of derivatives through finite differences. It may therefore be possible to loosen numerical solver convergence settings employed by the model; model run times may fall as a consequence. In addition to this, the chance of being trapped in a local objective function minimum is lowered as partial derivatives that are approximated using an ensemble are at least partially informed by broad scale parameter gradients in addition to local parameter gradients.
The use of an ensemble to calculate partial parameter derivatives does not come without a cost however. Because partial derivatives are approximate, it may not always be possible to achieve as good a fit with the calibration dataset for some or all members of an ensemble as that which can be achieved through adjustment of a single parameter field using partial derivatives calculated through finite parameter differences. Another problem is that even though the number of ensemble members may exceed the dimensionality of the inverse problem solution space, this does not forestall inadvertent entrainment of null space parameter components during the parameter adjustment process. This may introduce bias to some ensemble members. Both of these problems can be reduced by increasing the number of parameter fields that comprise the ensemble. Obviously, this comes at a numerical cost. (These problems can also be addressed through “localization”, a process that is described below.)
Another issue associated with the use of random parameter fields is that of model stability. If the model (or models) that is run by PESTPP-IES experiences numerical difficulties when provided with some parameter sets, then use of an ensemble of random parameter fields is likely to trigger occasional model run failures, or occasional simulations whose run times are excessively long. As will be discussed below, PESTPP-IES includes functionality to accommodate this problem.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 9. PESTPP-IES
- **Subsection:** 9.1 Introduction

### Additional Summaries
- **Higher-Level Summary:** Tikhonov regularization in PEST enhances stability by reducing error variance and incorporating expert knowledge. Use IREGADJ, SVD, or LSQR with MAXSING and EIGTHRESH settings for stability. PEST stops after NOPTMAX iterations, reaching target objectives, minimal parameter changes, or slow improvement. Regularization mode categorizes observations into "regul" groups, adjusting weights with a regularization weight factor.
- **Detailed Summary:** Tikhonov regularization enhances stability by reducing error variance and incorporating expert knowledge. To ensure stability, use IREGADJ, SVD, or LSQR with MAXSING and EIGTHRESH settings. PEST stops after NOPTMAX iterations, reaching target objectives, minimal parameter changes, or slow improvement. User termination is recommended, especially in early calibration.

### Related Context
- **Previous Summary:** PESTPP-IES offers two solution methods:  Evensen's (2003) Kalman update (including Emerick and Reynolds' 2013 MDA scheme) and Chen and Oliver's (2013) GLM method (default).  The Kalman update is optimal for linear, perfect models; iteration handles nonlinearity.  MDA uses iterative covariance inflation; GLM penalizes parameter changes.  Both methods are widely used.
- **Next Summary:** PESTPP-IES uses an iterative ensemble smoother to adjust parameter fields, requiring iterative updates of the Jacobian matrix and Marquardt lambda (high lambda for initial improvements, low lambda for fine-tuning).  Lambda values are tested using a subset of the ensemble;  the remaining members are then updated using the best lambda.  The same runs are used for both upgrade testing and Jacobian matrix updates.

### Metadata
- **Keywords:** 
- **Chunk ID:** 9a974492d993
- **Chunk Index:** 1
- **Previous Chunk ID:** 03daf70e019e
- **Next Chunk ID:** e43b2cf4ea24

---

## Context

### Summary
**PESTPP-MOU uses PEST control, template, and instruction files, similar to other PEST++ tools.**

### Header
**13.4.1 General**

### Content
Like all the tools in the PEST++ suite, PESTPP-MOU uses a control file, template files, and instruction files.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 13. PESTPP-MOU
- **Subsection:** 13.4 Summary of PESTPP-MOU Control Variables

### Additional Summaries
- **Higher-Level Summary:** PPD2ASC converts case.ppd to a textfile with objective function components, model outputs, and parameter values for spreadsheets. PPD2PAR extracts parameters from ppdfile to parfile for PEST utilities, matching objective function values in case.pod and case.par.N. Specific commands are required for each task.
- **Detailed Summary:** PEST2LHS generates a simplified Latin Hypercube Sampling (LHS) input file from a PEST control file and optional parameter uncertainty file. It supports limited LHS options and assumes normal/lognormal distributions for parameters. Users may manually adjust the output file for more complex functionality. Adjustable parameters are included, and peak probability is set using midpoints or initial values.

### Related Context
- **Previous Summary:** PESTPP-MOU outputs (Table 13.1, case=control file base name, <iter>=iteration number): case.rec (run history), case.rmr (parallel run management), case.log (performance log), case.pareto.summary.csv (Pareto solutions), and current/iteration-specific ensembles (case.chance.obs_pop.csv/jcb, case.chance.dv_pop.csv/jcb, case.obs_pop.csv/jcb, case.dv_pop.csv/jcb, case.<iter>.obs_pop.csv/jcb, case.<iter>.dv_pop.csv/jcb, case.<iter>.chance.obs_pop.csv/jcb, case.<iter>.chance.dv_pop.csv/jcb), and case.lineage.csv.  Files may be CSV or JCB depending on *SAVE_BINARY*.
- **Next Summary:** Table 13.2 lists optional PESTPP-MOU control variables (with defaults): *mou_population_size*, *mou_generator*, *mou_dv_population_file*, *mou_obs_population_restart_file*, *mou_objectives*, *mou_max_archive_size*, *mou_risk_obj*, *mou_verbose_level*, *mou_env_selector*, *mou_crossover_prob*, *mou_mutation_prob*, *mou_mating_selector*, *mou_de_f*, *mou_save_population_every*, *mou_pso_cognitive_const*, *mou_pso_omega*, *mou_pso_social_const*, *mou_population_schedule*, *mou_simplex_reflections*, *mou_simplex_factors*, *mou_simplex_mutation*, *mou_multigen_population*, and *mou_chance_schedule*.  Parallel run management variables (section 5.3.6) are not included.  The latest variables are available on the PEST++ website.

### Metadata
- **Keywords:** 
- **Chunk ID:** 6be9206a9998
- **Chunk Index:** 1
- **Previous Chunk ID:** 05b85a679d12
- **Next Chunk ID:** 3bcdf0b82a44

---

## Context

### Summary
**PESTGEN, Groundwater/Surface Water utilities aid PEST input file creation; TEMPCHEK, INSCHEK, and PESTCHEK check file integrity. PWTADJ1 and WTFACTOR adjust weights. EIGPROC and PHISTATS summarize inversion results; PARREP populates new control files.**

### Header
**1.7.2 Over-Determined Model Calibration**

### Content
Where a small number of parameters must be estimated, there is no need to include regularisation in a PEST control file. The PESTGEN utility can assist in PEST input file preparation. However programs provided with the PEST Groundwater and Surface Water Utility suite may provide more comprehensive assistance in PEST input dataset construction.
The integrity of PEST template and instruction files can be checked using the TEMPCHEK.
and INSCHEK utilities. The integrity of the entire PEST input dataset can be checked using the PESTCHEK utility.
After one model run has been completed, weights balancing between observation groups featured in the PEST dataset can be implemented using PWTADJ1. WTFACTOR provides further assistance in weights adjustment where observation numbers are large.
Upon completion of the parameter estimation process, EIGPROC can summarize information that is pertinent to the well-posedness (or otherwise) of that process. PHISTATS can provide a summary of objective function behaviour during the inversion process. If you wish to build a new PEST dataset starting with parameters calculated during the current PEST run, you can use the PARREP utility to populate the new PEST control file accordingly.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 1. Introduction
- **Subsection:** 1.7 Some Common Tasks

### Additional Summaries
- **Higher-Level Summary:** To install PEST, copy its executables to a folder in the PATH variable for access from any directory. The suite includes PEST, Parallel PEST, BEOPEST, SENSAN, global optimizers, and utilities. PEST calibrates models by matching outputs to measurements, handling non-uniqueness through regularization. It quantifies uncertainties and supports decision-making by identifying unlikely events.
- **Detailed Summary:** This section introduces PEST's capabilities, including utilities like PESTGEN for file creation, TEMPCHEK for file integrity, and EIGPROC for inversion results. Other utilities adjust weights, analyze worth, and manipulate matrices. Part II covers additional matrix operations and global optimizers if needed. Groundwater and Surface Water Utilities are documented separately.

### Related Context
- **Previous Summary:** This section introduces PEST's capabilities by listing tasks and associated programs,  even referencing concepts explained later in the manual.  It aims to familiarize new users with PEST and its utilities.
- **Next Summary:** ADDREG1 adds Tikhonov regularization to a PEST control file.  SSSTAT, IDENTPAR, GENLINPRED, and PREDUNC7 provide parameter and observation statistics and identifiabilities. SUPCALC and SVDAPREP support SVD-assisted inversion.

### Metadata
- **Keywords:** 
- **Chunk ID:** 4d55e9e38ac5
- **Chunk Index:** 1
- **Previous Chunk ID:** 41dda665a758
- **Next Chunk ID:** 814022ba60ae

---

## Context

### Summary
**Install PEST; the ppestex folder contains Parallel PEST files. Create test1 and test2 subfolders; run pagent in each, specifying the model command ("..\a_model"). Run ppest test (or pest test for serial) from the ppestex folder. For this case, serial PEST is faster due to low model runtime; reducing WAIT in test.rmf may improve Parallel PEST speed.**

### Header
**11.3.12 An Example**

### Content
Once PEST has been installed on your machine, a subdirectory of the main PEST directory (i.e. folder) named ppestex will contain all the files needed to undertake a Parallel PEST run on a single machine. Before running this example make sure that the PEST folder is cited in the PATH environment variable.
Open a command line window in the ppestex folder and create two subfolders of this folder named test1 and test2.
Now open two more command line windows. In one of these windows transfer to subfolder test1 and type the command pagent. When prompted for the command to run the model, type ..\a_model. Do the same in the other command line window for folder test2.
In the first command line window (i.e. the window that is open in the ppestex folder) type the command ppest test.
Parallel PEST should commence execution and, after verifying that it can communicate with each of its agents, undertake parameter estimation for the a_model model.
If you wish, you can also carry out the parameter estimation process using the normal, serial, version of PEST. While situated in the ppestex folder type pest test.
For this particular case serial PEST runs faster than Parallel PEST. This is because the model run time is too small to justify Parallel PEST’s run management overheads. Note, however, that Parallel PEST’s speed can be increased somewhat by reducing the value of the WAIT variable from that provided in the test.rmf run management file.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 11. Parallel PEST and BEOPEST (continuación)
- **Subsection:** 11.3 Using Parallel PEST

### Additional Summaries
- **Higher-Level Summary:** Parallel PEST and BEOPEST parallelize model runs to reduce run time. Parallel PEST needs a run management file, while BEOPEST's is optional. Both distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Parallel PEST uses PAGENT agents, requires separate folders for agents, and shared signal files for communication. BEOPEST offers ease of use, faster communication, flexibility, and support for multiple command lines and surrogate models.
- **Detailed Summary:** Prepare standard PEST input files and check them using PESTCHEK. Create a Parallel PEST run management file ensuring model runs correctly in each agent folder. Install PEST on each agent machine. Adjust WAIT in run management file to prevent file access conflicts. Parallel PEST manages runs intelligently, reassigning slow runs, and can be restarted mid-process.

### Related Context
- **Previous Summary:** Parallel PEST responds to PPAUSE, PSTOP, or PSTOPST commands with a short delay (depending on WAIT).  However, a significant delay can occur if PEST encounters a model output file reading problem; it retries three times before stopping, ignoring pest.stp during retries and reporting problems to the run management record file.
- **Next Summary:** BEOPEST (by Schreuder and Rumbaugh), is preferred over Parallel PEST due to ease of use (no run management file needed), faster communication (TCP/IP), greater flexibility (fewer network permissions), and support for multiple command lines (and surrogate models via observation re-referencing).

### Metadata
- **Keywords:** 
- **Chunk ID:** 2f64732711fc
- **Chunk Index:** 1
- **Previous Chunk ID:** b7eaedb35028
- **Next Chunk ID:** 1d6778b18305

---

## Context

### Summary
**Instruction files are created via text editor or specialized software.  Errors cause run-time errors or unexpected results. PESTCHEK (for all instruction files) and INSCHEK (for a single file) verify instruction file syntax and can test output reading.**

### Header
**2.3.7 Making an Instruction File**

### Content
An instruction file can be built using a text editor. Alternatively it can be written by software dedicated to this purpose such as a model graphical user interface which supports PEST, or members of the Groundwater and Surface Water Utilities downloadable from the PEST web pages.
Caution must always be exercised in building an instruction set to read a model output file, especially if navigational instructions such as markers, whitespace, tabs and dummy observations are used. PEST will always follow your instructions to the letter, but it may not read the number you intend it to read if you get an instruction wrong. If PEST tries to read an observation but does not find a number where it expects to find one, a run-time error will occur. PEST will inform you of where it encountered the error, and of the instruction it was implementing when the error occurred; this should allow you to find the problem. However if PEST actually reads the wrong number from the model output file, this may only become apparent if an unusually high objective function results, or if PEST is unable to lower the objective function on successive optimisation iterations. Alternatively if the number which PEST is instructed to read is a model prediction, or if PEST is being asked purely to compute sensitivities of this number to model parameters, the error may never be apparent. If in doubt, check PEST-generated files for numbers that PEST reads from model output files to make sure that they meet expectations.
Included in the PEST suite are two programs which can be used to verify that instruction files have been built correctly. Program PESTCHEK, when checking all PEST input data for errors and inconsistencies prior to a PEST run, reads all the instruction files cited in a PEST control file ensuring that no syntax errors are present in any of these files. Program INSCHEK, on the other hand, checks a single PEST instruction file for syntax errors. If an instruction file is error-free, INSCHEK can then use that instruction file to read a model output file, printing out a list of observation values read from that file. In this way you can be sure that your instruction set “works” before it is actually used by PEST.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 2. The Model-PEST Interface
- **Subsection:** 2.3 Instruction Files

### Additional Summaries
- **Higher-Level Summary:** PEST software uses template, instruction, and control files for model input and output. Templates, created with text editor or software, are validated with TEMPCHEK, INSCHEK, and PESTCHEK. Parameters are replaced in templates, and model input files should match for precision. Instruction files extract model outputs. Precision is crucial for accurate derivative calculations.
- **Detailed Summary:** PEST uses instruction files to extract "observations" (model outputs) from model output files (maximum width: 2000 characters).  Observations may be calibration data, predictions, or sensitivity targets.  Terminal output can be redirected to a file for PEST processing; instruction files are suggested to use a ".ins" extension.

### Related Context
- **Previous Summary:** Non-fixed observations "!obsname!" use preceding instructions (whitespace "w", secondary markers) for location. Dummy observations "!dum!" aid navigation; they are not matched to data in the control file.  Secondary markers after observations prevent including trailing non-numeric characters.  "&" continues instruction lines across multiple lines.
- **Next Summary:** This chapter provides a PEST overview, referencing Doherty (2015) for theoretical details.  Control variables (detailed later) affect PEST's operation.  Part I covers PEST, SCEUA_P, CMAES_P, and SENSAN; Part II covers supporting utilities.

### Metadata
- **Keywords:** 
- **Chunk ID:** 9d367608c018
- **Chunk Index:** 1
- **Previous Chunk ID:** ab3c8250e5ef
- **Next Chunk ID:** 75f6986ebb4a

---
