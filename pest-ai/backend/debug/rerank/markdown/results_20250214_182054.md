# Search Results for: What is NUMLAM?

Keywords: numlam

## Variations
1. What is NUMLAM?
2. Explain what NUMLAM is
3. Define NUMLAM
4. Describe NUMLAM
5. Tell me about NUMLAM


## Context

### Summary
**In Parallel PEST, a negative NUMLAM value in the PEST control file automatically sets PARLAM to -9999, overriding the run management file's PARLAM value. The number of parallel model runs then equals the absolute value of NUMLAM.**

### Header
**11.2.7 PARLAM Override**

### Content
If NUMLAM is set to a negative number in the PEST control file, and if PEST is run as Parallel PEST, the PARLAM variable is automatically set to -9999. The number of parallel model runs used in the Marquardt lambda testing procedure is then equal to the absolute value of NUMLAM. For Parallel PEST a negative NUMLAM value thus overrides the PARLAM value provided in the run management file.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 11. Parallel PEST and BEOPEST (continuación)
- **Subsection:** 11.2 Parallel PEST – Concepts and Specifications

### Additional Summaries
- **Higher-Level Summary:** Parallel PEST and BEOPEST parallelize model runs to reduce run time. Parallel PEST needs a run management file, while BEOPEST's is optional. Both distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Parallel PEST uses PAGENT agents, requires separate folders for agents, and shared signal files for communication. BEOPEST offers ease of use, faster communication, flexibility, and support for multiple command lines and surrogate models.
- **Detailed Summary:** Parallel PEST distributes model runs across networked machines, using a PAGENT agent program on each machine. It requires separate folders for agents to avoid file conflicts and uses shared signal files for communication. The run management file lists agents, runtimes, and filenames. Parallel PEST partially parallelizes Marquardt lambda testing, potentially leading to different solution paths.

### Related Context
- **Previous Summary:** PARLAM (non-zero negative integer) limits agents in parallel lambda testing; -9999 runs one cycle (NUMLAM runs), using a wider range of lambdas (RLAMFAC becomes its negative), and processes all results regardless of trends. This is recommended with many nodes but may increase model failure risk (mitigated by LAMFORGIVE); parameter freezing is also affected.
- **Next Summary:** In Parallel PEST, agents can be assigned to groups (Figure 11.6), listed after AGENTDIR in the run management file. All agents must be grouped; group names (case-insensitive) are quoted if they contain spaces.  PEST prioritizes allocating runs to different groups when the number of runs is less than the number of agents to minimize load per machine.

### Metadata
- **Keywords:** NUMLAM
- **Chunk ID:** c666fa5fe8ca
- **Chunk Index:** 1
- **Previous Chunk ID:** bdc8c3cc13a0
- **Next Chunk ID:** 22a1387338d9

---

## Context

### Summary
**PARLAM (non-zero negative integer) limits agents in parallel lambda testing; -9999 runs one cycle (NUMLAM runs), using a wider range of lambdas (RLAMFAC becomes its negative), and processes all results regardless of trends. This is recommended with many nodes but may increase model failure risk (mitigated by LAMFORGIVE); parameter freezing is also affected.**

### Header
**11.2.6 Alternative PARLAM Settings**

### Content
In response to this imperative, PARLAM can be set to a negative number. As long as it is non-zero, partial parallelisation of the lambda search procedure is activated. However the number of agents involved in this lambda search procedure is limited to the absolute value of PARLAM. Thus, for example, if parallelisation is being undertaken using 50 agents, and if PARLAM is set to -4, then Parallel PEST involves only 4 agents in the partial parallelisation of lambda testing.
A PARLAM setting of -9999 however has special significance. This setting should only be employed where a user has access to a relatively large number of computing nodes of equal power. If PARLAM is set to -9999, the parallel lambda testing procedure follows the strategy set out below.
1. Only one cycle of parallel runs is devoted to testing Marquardt lambdas; PEST will not commit to a second cycle, irrespective of results forthcoming from the first cycle.
2. The maximum number of parallel runs constituting this cycle is set to NUMLAM, the variable in the “control data” section of the PEST control file which sets the
maximum number of lambda-testing runs undertaken per iteration. However if there are less agents than NUMLAM available at the time that lambda testing is required, NUMLAM is temporarily reduced to the number of available agents.
1. If it is not supplied as a negative number, RLAMFAC (the lambda multiplier employed in lambda testing) is set internally to the negative of its supplied value. Hence, as described in section 4.2.6 of this manual, a much wider range of lambda values is tested than would be the case if a value-independent multiplier were employed.
2. Tested lambda values (on different agent machines) are disposed in equal numbers above and below the current value of the Marquardt lambda.
3. The outcomes of all such runs are read, irrespective of “trends” discovered from the processing of early returns. Thus if the dependence of the objective function on the Marquardt lambda is irregular (such as can occur if finite-difference derivatives are compromised as a result of model output granularity), an “accidental” low objective function corresponding to a random lambda will not be missed.
Use of a PARLAM setting of -9999 is recommended where a user has access to a large number of computing nodes, many of which would be standing idle while implementing a partially parallelised lambda testing strategy. The user must remember however, that the number of model runs employed for lambda testing is set by NUMLAM, and not by the number of agents/nodes available. Hence NUMLAM may need to be set higher than normal. Note also that, as stated above, only one round of lambda-testing runs is undertaken.
It is important to note that for all PARLAM settings other than -9999 Parallel PEST will serialize the lambda testing procedure if any parameter hits its bound, even though it may have commenced the lambda testing procedure as a parallelised process. As stated above, this is because it reformulates the inverse problem to accommodate the fact that the parameter is temporarily non-adjustable.
Despite its advantages, caution should be exercised when setting PARLAM to -9999. If a model is susceptible to crashing when it is supplied with parameter values that it finds unpalatable, this is most likely to occur during the lambda testing procedure, for this is the part of the parameter estimation process where parameter values are most different from those that have been employed previously. Testing of a wide range of lambda values in this parallel fashion can increase the chances of model run failure. Note, however, that PEST failure can be prevented through an appropriate setting of the LAMFORGIVE control variable. This can reduce some of the risks associated with setting PARLAM to -9999.
Another negative feature of a -9999 PARLAM setting is that PEST’s ability to sequentially and temporarily freeze parameters that have hit their bounds (and re-formulate the inverse problem accordingly) is compromised to some extent. Nevertheless the methodology for partially parallelised lambda testing supported by a PARLAM value of -9999 can be of great use where, as stated above, model derivatives are compromised because of model numerical imperfections, and/or the number of processors to which Parallel PEST has access is high.
If setting PARLAM to -9999, it is a good idea to set RLAMFAC to a higher negative value than normal (for example a value of -4 rather than the recommended values of -2 or -3) so that it can sample the objective function vs. lambda curve in greater detail (perchance to fall into objective function crevices in a possibly noisy relationship between Marquardt lambda and the objective function).

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 11. Parallel PEST and BEOPEST (continuación)
- **Subsection:** 11.2 Parallel PEST – Concepts and Specifications

### Additional Summaries
- **Higher-Level Summary:** Parallel PEST and BEOPEST parallelize model runs to reduce run time. Parallel PEST needs a run management file, while BEOPEST's is optional. Both distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Parallel PEST uses PAGENT agents, requires separate folders for agents, and shared signal files for communication. BEOPEST offers ease of use, faster communication, flexibility, and support for multiple command lines and surrogate models.
- **Detailed Summary:** Parallel PEST distributes model runs across networked machines, using a PAGENT agent program on each machine. It requires separate folders for agents to avoid file conflicts and uses shared signal files for communication. The run management file lists agents, runtimes, and filenames. Parallel PEST partially parallelizes Marquardt lambda testing, potentially leading to different solution paths.

### Related Context
- **Previous Summary:** Parallel PEST partially parallelizes Marquardt lambda testing.  It runs models with multiple lambdas concurrently; however, runs exceeding 1.8 times the fastest run are excluded.  The "packet" size equals the number of fast agents.  Decision-making occurs after each packet, potentially wasting some runs. The process differs from serial lambda testing, potentially leading to different paths to the solution.  Limiting the number of agents is recommended to prevent problems from widely varying lambdas.
- **Next Summary:** In Parallel PEST, a negative NUMLAM value in the PEST control file automatically sets PARLAM to -9999, overriding the run management file's PARLAM value. The number of parallel model runs then equals the absolute value of NUMLAM.

### Metadata
- **Keywords:** LAMFORGIVE, NUMLAM, RLAMFAC, lambdas
- **Chunk ID:** bdc8c3cc13a0
- **Chunk Index:** 2
- **Previous Chunk ID:** e4b1d5dd3fcb
- **Next Chunk ID:** c666fa5fe8ca

---

## Context

### Summary
**BEOPEST does not require a run management file but will read PARLAM and RUN_SLOW_FAC from it if present. PARLAM settings (0, 1, -N, -9999) control parallel lambda searching; -9999 is best for many agents with similar runtimes and long model run times. A negative NUMLAM in the control file sets PARLAM to -9999, overriding the run management file. RUN_SLOW_FAC (real, >1.0) sets the threshold for considering a run overdue.**

### Header
**11.4.10 The Run Management File, PARLAM and RUN_SLOW_FAC**

### Content
Unlike Parallel PEST, BEOPEST does not need to read a run management file. Recall that this file has the same filename base as the PEST control file, but has an extension of “.rmf”. As the agents, and not the manager, write model input files and read model output files, the manager does not need to know the names and locations of agent working folders. Nor does it need to know in advance of a BEOPEST run how many agents are at its disposal. It will simply add agents to its register as they open communications with the BEOPEST manager through the TCP/IP protocol, and allocate them runs as long as they are still prepared to implement these runs.
Nevertheless, if a run management file is present within the directory from which the manager is launched, the BEOPEST manager will read the first two lines of this file. Actually it will only read two variables from this file. The first is PARLAM; the second is the optional RUN_SLOW_FAC variable. PARLAM is the fourth variable on the second line of the run management file, while RUN_SLOW_FAC can be placed anywhere on this line. Note that BEOPEST will not read the WAIT variable. Hence BEOPEST cannot be instructed to temporarily pause its run management at critical moments so that the operating system can catch up with it; this is unnecessary.
PARLAM
Recall from section 11.2.6 above that PARLAM settings are as follows.
|PARLAM setting|PEST action|
|---|---|
|0|Do not parallelise model runs when testing different parameter upgrades calculated on the basis of different Marquardt lambdas.|
|1|Parallelise the lambda search procedure. Use all available agents in this process. Return to serial processing if a parameter hits its bound.|
|-N|Parallelise the lambda search procedure. Use a maximum of N agents in this process. Return to serial processing if a parameter hits its bound.|
|-9999|Parallelise the lambda search procedure. Use a maximum of NUMLAM agents, and undertake only one round of lambda testing.|
As is explained above, a setting of -9999 is the best to use where model run times are long.
and where a user has access to a moderate to high number of agents whose run times are similar. In that case it may be wise to set the NUMLAM variable in the “control data” section of the PEST control file to a higher-than-normal value if it would otherwise be smaller than the number of available agents. (Recall that the NUMLAM variable governs the maximum number of model runs that PEST will commit to the testing of different Marquardt lambdas.) However a value of 15 is normally high enough.
As was stated above, it is important to note that for all PARLAM settings other than -9999, PEST abandons parallelisation of the lambda search procedure if any parameter encounters its bounds. Traditional lambda-based upgrading then becomes a serial procedure as the parameter upgrade direction is re-calculated in a manner that is dependent on the number of parameters that have not yet encountered their bounds. However with PARLAM set to -9999, PEST will, under no circumstances, undertake a second set of model runs during the lambda testing procedure pertaining to any one iteration of the inversion process; nor will it serialize the lambda search procedure. This ensures that no processors are idle during the lambda testing procedure. Where a user has many processors at his/her disposal, some lack of efficiency in conducting the lambda search that is incurred through failure to serialize this search as parameters encounter their bounds, may be more than compensated by efficiencies gained through keeping all processors busy.
If you wish, you can provide BEOPEST with a PARLAM setting of -9999 without having to provide a run management file. If NUMLAM is set to a negative number in the PEST control file, then if PEST is run as Parallel PEST or BEOPEST, the PARLAM variable will automatically be set to -9999. The number of parallel model runs used in the Marquardt lambda testing procedure is then equal to the absolute value of NUMLAM. If a run management file is present, a negative NUMLAM value overrides the PARLAM value setting provided in that file.
RUN_SLOW_FAC
If you wish to provide BEOPEST with a value for RUN_SLOW_FAC then a run management file must be present in the folder in which the BEOPEST manager is run. Recall from section 11.2.5 that this variable is optional and can be placed anywhere on the second line of this file. In fact, if supplied to BEOPEST, all other variables can be missing from this line and BEOPEST will not care. Figure 11.7 shows a run management file suitable for the use of BEOPEST in which RUN_SLOW_FAC is assigned a value of 5.0. Because all other variables are missing from this line PARLAM is assigned a default value of 1; alternatively it may have been assigned a value of -9999 through a negative NUMLAM setting in the PEST control file.
prf
run_slow_fac = 5.0
Figure 11.7 A run management file for the use of BEOPEST in which it is supplied a value for RUN_SLOW_FAC.
BEOPEST will also accept a run management file such as that depicted in figure 11.5 in which other variables are represented on its second line.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 11. Parallel PEST and BEOPEST (continuación)
- **Subsection:** 11.4 BEOPEST

### Additional Summaries
- **Higher-Level Summary:** Parallel PEST and BEOPEST parallelize model runs to reduce run time. Parallel PEST needs a run management file, while BEOPEST's is optional. Both distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Parallel PEST uses PAGENT agents, requires separate folders for agents, and shared signal files for communication. BEOPEST offers ease of use, faster communication, flexibility, and support for multiple command lines and surrogate models.
- **Detailed Summary:** BEOPEST, a preferred option over Parallel PEST, offers ease of use, faster communication via TCP/IP, flexibility, and support for multiple command lines and surrogate models. It does not require a run management file but can read certain settings from it. Agents are "smart," handling input and output files locally.

### Related Context
- **Previous Summary:** BEOPEST supports multiple model command lines (NUMCOM > 1 in the "control data" section), sending the command index to each agent.  All necessary files must be accessible from all agent folders.  Parameter-specific command indices are set using DERCOM in the "parameter data" section.
- **Next Summary:** BEOPEST's run management record file (case.rmr) logs communication between the manager and agents; it uses the same filename base as the PEST control file.

### Metadata
- **Keywords:** NUMLAM, lambdas
- **Chunk ID:** d693b4aa5fb9
- **Chunk Index:** 1
- **Previous Chunk ID:** d535c6f4c51d
- **Next Chunk ID:** fa495ccc2398

---

## Context

### Summary
**PESTCHEK verifies PEST input datasets (control, template, and instruction files), checking for syntax errors and consistency (including parameter/observation counts, bounds, transformations, and prior information). It ignores PEST++-specific variables ("++" prefix) but can partially check PEST++ datasets.  Use `pestchek case`; the `/s` switch omits template/instruction file checks. *CHECK_TPLINS* (Boolean) controls parameter/observation alignment checks.**

### Header
**4.5 The PESTCHEK Utility**

### Content
PESTCHEK is a utility program that is supplied with the PEST suite. It reads an entire PEST input dataset, this being comprised of a PEST control file and all template and instruction files cited therein. It checks all of these files for correctness and consistency. In doing so, it performs all of the tasks performed by the TEMPCHEK and INSCHEK utilities that were mentioned in chapter 2 of this manual. However, it goes further than this. It ensures that any parameter that is cited in a template file is also cited in a PEST control file (and vice versa), and that any observation that is cited in an instruction file is also cited in the PEST control file (and vice versa). The benefits of such checking are obvious.
PESTCHEK also subjects a PEST control file to thorough error and consistency checking. For example, it informs a user if a parameter is not between its upper and lower bounds, or if a parameter which is denoted as being log-transformed is endowed with a zero or negative initial value. It checks that the number of tied-parent parameter relationships that are provided in the second half of the “parameter data” section of a PEST control file are in accordance with the number of parameters that are denoted as being tied in the first half of this section. Consistency checks are made between equations comprising the “prior information” section of a PEST control file and the transformation status of parameters in the “parameter data” section of the PEST control file.
PESTCHEK ignores lines in a PEST control file that begin with the “++” string. Hence it performs no checking of control variables that are specific to members of the PEST++ suite. The above examples of its checking functionality indicate, however, that it can still be used to at least partially ensure the quality of a PEST++ input dataset. However, if it is to provide this service, certain conditions must be met. These include the following.
- Variables such as NOBS, NPARGP, NOBSGP and NPRIOR that are ignored by programs of the PEST++ suite, but that are read by PESTCHEK (and PEST), should have the correct values. These indicate the number of observations, parameter groups, observation groups and prior information equations respectively that are featured in a PEST control file. (Programs of the PEST++ suite evaluate these numbers themselves based on the contents of respective sections of a PEST control file.)
- Control variables such as those which govern PEST’s calculation of the Marquardt lambda (RLAMBDA1, RLAMFAC, PHIRATSUF, PHIREDLAM and NUMLAM) should be coherent. Suitable values are suggested below for these and other variables, though little will be said about their usage by PEST.
Variables appearing in a PEST control file which are used by members of the PEST++ suite are now described. At the same time, sensible, PESTCHEK-safe placeholder values are provided for all variables whose presence is required in a PEST control file, but which are not actually used by members of the PEST++ suite. The interested reader is referred to part I of the PEST manual for further details.
Note that all of the PEST++ tools will check that the parameters and observations between the control file and template/instruction files are aligned. This checking can be disabled by setting *CHECK_TPLINS* to false.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 4. The PEST Control File
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** Figure 4.1 shows PEST control file variables; shaded variables are used by PEST++, some are optional.  The first line is "pcf". Values are space/tab delimited; strings with spaces are quoted.  Blank lines and comments (#) are allowed (PEST ≥15, PEST++ ≥4).  PEST++ ignores some sections (Table 4.1);  PEST++-specific variables use the "++" prefix.
- **Next Summary:** Figure 4.3 shows the "control data" section of a minimalist PEST control file, including RSTFLE, PESTMODE, NPAR, NOBS, NPARGP, NPRIOR, NOBSGP, NTPLFLE, NINSFLE, PRECIS, DPOINT, RLAMBDA1, RLAMFAC, PHIRATSUF, PHIREDLAM, NUMLAM, RELPARMAX, FACPARMAX, FACORIG, PHIREDSWH, NOPTMAX, PHIREDSTP, NPHISTP, NPHINORED, RELPARSTP, NRELPAR, ICOV, ICOR, and IEIG.  Some variables are optional, indicated by square brackets.

### Metadata
- **Keywords:** NOBS, NOBSGP, NPARGP, NPRIOR, NUMLAM, PHIRATSUF, PHIREDLAM, RLAMBDA1, RLAMFAC
- **Chunk ID:** c08ee11876f8
- **Chunk Index:** 1
- **Previous Chunk ID:** 4b679027f965
- **Next Chunk ID:** 3cf73a612e5f

---

## Context

### Summary
**PEST iteratively adjusts Marquardt lambda (RLAMBDA1, RLAMFAC) to minimize the objective function.  It stops when the objective function reduction is less than PHIRATSUF or PHIREDLAM (Equation 4.2.3). NUMLAM limits lambda tests per iteration.  JACUPDATE (optional) enables Broyden Jacobian updates. LAMFORGIVE ("lamforgive" or "nolamforgive") handles model run failures.**

### Header
**4.2.6 Fifth Line**

### Content
The first lambda that PEST employs in calculating the parameter upgrade vector during any particular iteration is the lambda inherited from the previous iteration, possibly reduced by a factor of RLAMFAC (unless it is the first iteration, in which case RLAMBDA1 is used). Unless, through the use of this lambda, the objective function is reduced to less than PHIRATSUF of its value at the beginning of the iteration, PEST then tries another lambda,
less by a factor of RLAMFAC than the first. If the objective function is lower than for the first lambda (and still above PHIRATSUF of the starting objective function), PEST reduces lambda yet again; otherwise it increases lambda to a value greater by a factor of RLAMFAC than the first lambda for the iteration. If, in its attempts to find a more effective lambda by lowering and/or raising lambda in this fashion, the objective function begins to rise, PEST accepts the lambda and the corresponding parameter set giving rise to the lowest objective function for that iteration, and moves on to the next iteration. Alternatively if the relative reduction in the objective function between the use of two consecutive lambdas is less than PHIREDLAM, PEST takes this as an indication that it is probably more efficient to begin the next iteration than to continue testing the effect of new Marquardt lambdas. Thus if
(j-1 - j)/j-1 ≤ PHIREDLAMi i i (4.2.3)
where ij is the objective function value calculated during optimisation iteration i using the j’th trial lambda, PEST moves on to iteration i+1.
A suitable value for PHIREDLAM is between 0.01 and 0.05. If it is set too large, the criterion for moving on to the next iteration is too easily met and PEST is not given the opportunity of adjusting lambda to its optimal value for that particular stage of the parameter estimation process. On the other hand if PHIREDLAM is set too low, PEST will test too many Marquardt lambdas on each iteration of the inversion process when it would be better off starting a new iteration. (Note that where model runs are parallelised, the testing of too many Marquardt lambdas may not be so much of an issue as it keeps otherwise idle processors busy.)
NUMLAM
This integer variable places an upper limit on the number of lambdas that PEST will test during any one iteration. It should normally be set between 5 and 10 (normally closer to 10); however if RLAMBDA1 is set to zero (which is not recommended) it must be set to 1.
JACUPDATE
The Broyden Jacobian update procedure is described in section 5.4.2 of Doherty (2015). It provides a mechanism for improving the Jacobian matrix based on model outputs calculated during model runs undertaken for the purpose of testing parameter upgrades calculated using different values of the Marquardt lambda.
If JACUPDATE is omitted from the fifth line of the “control data” section of the PEST control file, or if it is set to zero, Broyden updating of the Jacobian matrix does not occur. However if it is set to n, where n is a positive integer, Broyden updating will be undertaken during the second part of every PEST iteration following the first n attempts to upgrade parameters using n different values of the Marquardt lambdas. Alternatively, it can be set to 999. In this case the Jacobian matrix is updated after the first parameter upgrade attempt, and every parameter upgrade attempt thereafter.
Experience indicates that Broyden Jacobian updating can work well on most occasions, but on some occasions does not. At the time of writing it is difficult to predict when it is likely to work well and when the opposite is likely to occur. The “safest” option is not to activate it as it can, under some circumstances, actually hinder the progress of the inversion process. Still, these occasions appear to be relatively rare, and in the majority of cases it is worth a try.
LAMFORGIVE
Sometimes, when a model is provided with a particular set of parameters, it fails to run to completion. Its output file is not then written. PEST reports this error condition and ceases execution with an appropriate error message. This situation is most likely to arise during those phases of the parameter estimation process where PEST is altering the value of the Marquardt lambda and testing new upgraded parameter values; this is the stage of the inversion process where parameters provided to the model are most different from their predecessors, and hence where model run failure is most likely to occur.
In most deployment contexts, a better course of action for PEST to take is to ignore the failed model run and attempt calculation of further parameter upgrades using other values of the Marquardt lambda. This response to model run failure can be instigated using the LAMFORGIVE variable.
LAMFORGIVE should be placed on the fifth line of the “control data” section of the PEST control file following the JACUPDATE variable if it is present, or the NUMLAM variable if JACUPDATE is absent. (Actually LAMFORGIVE can be placed in front of the JACUPDATE variable if desired.) It must be supplied as “lamforgive” (to activate model run failure forgiveness) or “nolamforgive” (to de-activate model run failure forgiveness). If it is omitted, a default value of “nolamforgive” is used by PEST.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 4. The PEST Control File
- **Subsection:** 4.2 Control Data Section

### Additional Summaries
- **Higher-Level Summary:** Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.
- **Detailed Summary:** Figure 4.2 shows "control data" section variables (from Appendix A, Figure A1.1).  Some variables are discussed later. The first line must be "* control data";  some variables are optional (in brackets).

### Related Context
- **Previous Summary:** RLAMBDA1 (initial Marquardt lambda, ~10.0) and RLAMFAC (Marquardt lambda adjustment factor, ~2.0 or -3.0) control lambda adjustments during iterations.  PHIRATSUF (objective function reduction ratio, ~0.3) determines iteration completion; if not met, PHIREDLAM is used.
- **Next Summary:** If LAMFORGIVE is "lamforgive", PEST switches to central derivatives or stops if no lambda produces a successful model run.  Failed parameter sets are saved in ###error.par files. DERFORGIVE ("derforgive" or "noderforgive") handles derivative calculation failures; "derforgive" sets derivatives to zero and reports missing files.

### Metadata
- **Keywords:** JACUPDATE, LAMFORGIVE, NUMLAM, PHIRATSUF, PHIREDLAM, RLAMBDA1, RLAMFAC, lambdas
- **Chunk ID:** 2995daaa6e7c
- **Chunk Index:** 2
- **Previous Chunk ID:** 9b975b5255bb
- **Next Chunk ID:** 9173261c3d0a

---
