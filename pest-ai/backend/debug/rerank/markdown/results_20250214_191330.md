# Search Results for: What is PHIRATSUF?

Keywords: phiratsuf

## Variations
1. What is PHIRATSUF?
2. Define PHIRATSUF
3. Explain what PHIRATSUF is
4. Describe PHIRATSUF
5. Tell me about PHIRATSUF


## Context

### Summary
**RLAMBDA1 (initial Marquardt lambda, ~10.0) and RLAMFAC (Marquardt lambda adjustment factor, ~2.0 or -3.0) control lambda adjustments during iterations.  PHIRATSUF (objective function reduction ratio, ~0.3) determines iteration completion; if not met, PHIREDLAM is used.**

### Header
**4.2.6 Fifth Line**

### Content
RLAMBDA1
This real variable is the initial Marquardt lambda. As discussed in the previous section, each iteration of the inversion process undertaken by PEST is divided into two parts. The first part comprises calculation of the Jacobian matrix. The second part is devoted to the testing of parameter upgrades that are calculated using different values of the Marquardt lambda. The role of the Marquardt lambda is described in section 5.4.2 of Doherty (2015).
During any one iteration of the inversion process PEST attempts parameter improvement using a number of different Marquardt lambdas. The starting value of the Marquardt lambda during any one iteration is inherited from the previous iteration; it is generally somewhat lower than that which allowed calculation of the lowest objective function during that iteration. Over the course of the entire inversion process the Marquardt lambda should generally fall. However it may rise if an inverse problem is poorly posed.
RLAMBDA1 is the initial value of the Marquardt lambda. This informs PEST of the first value that it should test during the first iteration of the inversion process. A value of 10.0 is appropriate in most cases. However if PEST complains about the normal matrix being singular you may need to raise it. (A better alternative would be to add regularisation to the PEST control file and/or employ singular value decomposition or LSQR as a solution mechanism for the inverse problem.)
RLAMFAC
RLAMFAC, a real variable, is the factor by which PEST adjusts the Marquardt lambda as it tests different values of this variable for their efficacy in lowering the objective function. RLAMFAC must be greater than 1.0; a value of 2.0 seems to work well on many occasions.
When PEST reduces lambda it divides by RLAMFAC; when it increases lambda it multiplies by RLAMFAC. PEST reduces lambda if it can. However if the inverse problem is nonunique and is unsupplemented by regularisation or by use of singular value decomposition or LSQR as a solution device, or if a reduction in lambda does not lower the objective function, PEST has no choice but to increase lambda.
Alternatively, the Marquardt lambda can be given a negative value less than -1.0. Suppose that it is given a value of -3.0. Then PEST will adjust the lambda adjustment factor during each iteration of the inversion process so that lambda can achieve a value of 1.0 with three adjustments (if PEST decides to move it in this direction). This allows rapid adjustment of the Marquardt lambda if this is suddenly required, as can happen if local parameter insensitivity.
promulgates sudden problem ill-posedness.
More specifically, suppose that RLAMFAC is supplied as –r where r is positive. Let λ be the value of the Marquardt lambda at the beginning of a particular iteration, this being inherited from the previous iteration as described above. Then a Marquardt lambda adjustment factor f for use in the current iteration is calculated as follows.
f = min[λ1/r, 2.0] if λ > 1.0 (4.2.1a)
f = min[(1/λ)1/r, 2.0] if λ < 1.0 (4.2.1b)
f = 2.0 if λ = 1.0 (4.2.1c)
If supplying a negative value for RLAMFAC it is important to note that the higher the absolute value assigned to a negative RLAMFAC, the smaller will be the actual iteration-specific Marquardt lambda adjustment factor. This is opposite to the case for a positive setting of RLAMFAC. In both cases however, the absolute value of RLAMFAC must be greater than 1.0.
An RLAMFAC value of -3.0 works well on most occasions.
PHIRATSUF
During any one iteration of the inversion process, PEST may calculate a parameter upgrade vector using a number of different Marquardt lambdas. First it lowers lambda and, if this is unsuccessful in lowering the objective function, it then raises lambda. If, at any stage, it calculates an objective function which is a fraction PHIRATSUF or less of the starting objective function for that iteration, PEST considers that the goal of the current iteration has been achieved and moves on to the next iteration. Thus PEST will commence iteration i+1 if, at any stage during iteration i
Φij/Φi-1 ≤ PHIRATSUF (4.2.2)
where Φi-1 is the lowest objective function calculated for iteration i-1 (and hence the starting value for iteration i) and Φj is the objective function corresponding to a parameter set i calculated using the j’th Marquardt lambda tested during iteration i.
PHIRATSUF (which stands for “phi ratio sufficient”) is a real variable for which a value of 0.3 is mostly appropriate. If it is set too low, model runs may be wasted in search of an objective function reduction which it is not possible to achieve, given the linearity approximation upon which the inversion equations described in Doherty (2015) are based. If it is set too high, PEST may not be given the opportunity of refining lambda in order that its value continues to be optimal as the inversion process progresses.
PHIREDLAM
If a new/old objective function ratio of PHIRATSUF or less is not achieved as the effectiveness of different Marquardt lambdas in lowering the objective function is tested, PEST must use some other criterion in deciding when it should move on to the next iteration. This criterion is partly provided by the real variable PHIREDLAM.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 4. The PEST Control File
- **Subsection:** 4.2 Control Data Section

### Additional Summaries
- **Higher-Level Summary:** Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.
- **Detailed Summary:** Figure 4.2 shows "control data" section variables (from Appendix A, Figure A1.1).  Some variables are discussed later. The first line must be "* control data";  some variables are optional (in brackets).

### Related Context
- **Previous Summary:** DERZEROLIM (optional) defines a Jacobian matrix zero threshold for compressed storage. NTPLFLE is the number of template files; NINSFLE is the number of instruction files. PRECIS ("single" or "double") sets precision. DPOINT ("point" or "nopoint") controls decimal point inclusion. NUMCOM, JACFILE, MESSFILE (Chapter 12) handle model-calculated derivatives. OBSREREF (Chapter 14) activates observation re-referencing.
- **Next Summary:** PEST iteratively adjusts Marquardt lambda (RLAMBDA1, RLAMFAC) to minimize the objective function.  It stops when the objective function reduction is less than PHIRATSUF or PHIREDLAM (Equation 4.2.3). NUMLAM limits lambda tests per iteration.  JACUPDATE (optional) enables Broyden Jacobian updates. LAMFORGIVE ("lamforgive" or "nolamforgive") handles model run failures.

### Metadata
- **Keywords:** PHIRATSUF, PHIREDLAM, RLAMBDA1, RLAMFAC, lambdas
- **Chunk ID:** 9b975b5255bb
- **Chunk Index:** 1
- **Previous Chunk ID:** e611a7673cad
- **Next Chunk ID:** 2995daaa6e7c

---

## Context

### Summary
**PEST iteratively adjusts Marquardt lambda (RLAMBDA1, RLAMFAC) to minimize the objective function.  It stops when the objective function reduction is less than PHIRATSUF or PHIREDLAM (Equation 4.2.3). NUMLAM limits lambda tests per iteration.  JACUPDATE (optional) enables Broyden Jacobian updates. LAMFORGIVE ("lamforgive" or "nolamforgive") handles model run failures.**

### Header
**4.2.6 Fifth Line**

### Content
The first lambda that PEST employs in calculating the parameter upgrade vector during any particular iteration is the lambda inherited from the previous iteration, possibly reduced by a factor of RLAMFAC (unless it is the first iteration, in which case RLAMBDA1 is used). Unless, through the use of this lambda, the objective function is reduced to less than PHIRATSUF of its value at the beginning of the iteration, PEST then tries another lambda,
less by a factor of RLAMFAC than the first. If the objective function is lower than for the first lambda (and still above PHIRATSUF of the starting objective function), PEST reduces lambda yet again; otherwise it increases lambda to a value greater by a factor of RLAMFAC than the first lambda for the iteration. If, in its attempts to find a more effective lambda by lowering and/or raising lambda in this fashion, the objective function begins to rise, PEST accepts the lambda and the corresponding parameter set giving rise to the lowest objective function for that iteration, and moves on to the next iteration. Alternatively if the relative reduction in the objective function between the use of two consecutive lambdas is less than PHIREDLAM, PEST takes this as an indication that it is probably more efficient to begin the next iteration than to continue testing the effect of new Marquardt lambdas. Thus if
(j-1 - j)/j-1 ≤ PHIREDLAMi i i (4.2.3)
where ij is the objective function value calculated during optimisation iteration i using the j’th trial lambda, PEST moves on to iteration i+1.
A suitable value for PHIREDLAM is between 0.01 and 0.05. If it is set too large, the criterion for moving on to the next iteration is too easily met and PEST is not given the opportunity of adjusting lambda to its optimal value for that particular stage of the parameter estimation process. On the other hand if PHIREDLAM is set too low, PEST will test too many Marquardt lambdas on each iteration of the inversion process when it would be better off starting a new iteration. (Note that where model runs are parallelised, the testing of too many Marquardt lambdas may not be so much of an issue as it keeps otherwise idle processors busy.)
NUMLAM
This integer variable places an upper limit on the number of lambdas that PEST will test during any one iteration. It should normally be set between 5 and 10 (normally closer to 10); however if RLAMBDA1 is set to zero (which is not recommended) it must be set to 1.
JACUPDATE
The Broyden Jacobian update procedure is described in section 5.4.2 of Doherty (2015). It provides a mechanism for improving the Jacobian matrix based on model outputs calculated during model runs undertaken for the purpose of testing parameter upgrades calculated using different values of the Marquardt lambda.
If JACUPDATE is omitted from the fifth line of the “control data” section of the PEST control file, or if it is set to zero, Broyden updating of the Jacobian matrix does not occur. However if it is set to n, where n is a positive integer, Broyden updating will be undertaken during the second part of every PEST iteration following the first n attempts to upgrade parameters using n different values of the Marquardt lambdas. Alternatively, it can be set to 999. In this case the Jacobian matrix is updated after the first parameter upgrade attempt, and every parameter upgrade attempt thereafter.
Experience indicates that Broyden Jacobian updating can work well on most occasions, but on some occasions does not. At the time of writing it is difficult to predict when it is likely to work well and when the opposite is likely to occur. The “safest” option is not to activate it as it can, under some circumstances, actually hinder the progress of the inversion process. Still, these occasions appear to be relatively rare, and in the majority of cases it is worth a try.
LAMFORGIVE
Sometimes, when a model is provided with a particular set of parameters, it fails to run to completion. Its output file is not then written. PEST reports this error condition and ceases execution with an appropriate error message. This situation is most likely to arise during those phases of the parameter estimation process where PEST is altering the value of the Marquardt lambda and testing new upgraded parameter values; this is the stage of the inversion process where parameters provided to the model are most different from their predecessors, and hence where model run failure is most likely to occur.
In most deployment contexts, a better course of action for PEST to take is to ignore the failed model run and attempt calculation of further parameter upgrades using other values of the Marquardt lambda. This response to model run failure can be instigated using the LAMFORGIVE variable.
LAMFORGIVE should be placed on the fifth line of the “control data” section of the PEST control file following the JACUPDATE variable if it is present, or the NUMLAM variable if JACUPDATE is absent. (Actually LAMFORGIVE can be placed in front of the JACUPDATE variable if desired.) It must be supplied as “lamforgive” (to activate model run failure forgiveness) or “nolamforgive” (to de-activate model run failure forgiveness). If it is omitted, a default value of “nolamforgive” is used by PEST.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 4. The PEST Control File
- **Subsection:** 4.2 Control Data Section

### Additional Summaries
- **Higher-Level Summary:** Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.
- **Detailed Summary:** Figure 4.2 shows "control data" section variables (from Appendix A, Figure A1.1).  Some variables are discussed later. The first line must be "* control data";  some variables are optional (in brackets).

### Related Context
- **Previous Summary:** RLAMBDA1 (initial Marquardt lambda, ~10.0) and RLAMFAC (Marquardt lambda adjustment factor, ~2.0 or -3.0) control lambda adjustments during iterations.  PHIRATSUF (objective function reduction ratio, ~0.3) determines iteration completion; if not met, PHIREDLAM is used.
- **Next Summary:** If LAMFORGIVE is "lamforgive", PEST switches to central derivatives or stops if no lambda produces a successful model run.  Failed parameter sets are saved in ###error.par files. DERFORGIVE ("derforgive" or "noderforgive") handles derivative calculation failures; "derforgive" sets derivatives to zero and reports missing files.

### Metadata
- **Keywords:** JACUPDATE, LAMFORGIVE, NUMLAM, PHIRATSUF, PHIREDLAM, RLAMBDA1, RLAMFAC, lambdas
- **Chunk ID:** 2995daaa6e7c
- **Chunk Index:** 2
- **Previous Chunk ID:** 9b975b5255bb
- **Next Chunk ID:** 9173261c3d0a

---

## Context

### Summary
**PESTPP-PSO (parallel only) uses a PEST control file (Chapter 4) and a PSO control file (specified via "++PSO(case.pso)") for multi-objective optimization (Siade et al. 2019, Coello et al. 2004). PESTPP-GLM starts agents.  PESTPP-PSO uses data from the PEST control file (Figure 11.1, shaded variables) and is compatible with PEST and its utilities.  Dummy values are needed for unused PEST variables.**

### Header
**11.1.1 General**

### Content
PESTPP-PSO was developed using the FORTRAN interface provided within the PEST++ source code. Currently, PESTPP-PSO is only designed to operate in parallel, and the command to execute the “manager” is as follows (which differs slightly from the other PEST++ calling programs),
| pestpp-pso case*.*pst port |
|----------------------------|
where, *case* represents the base name for the modeling study and *port* is the port number over which communications occur (please see previous documentation in this manual on the general usage of PEST++, e.g., Chapter 5). The main control file follows the format of a standard PEST control file (see Chapter 4). The calling program, PESTPP-PSO, will obtain most of the data regarding the optimization problem from this PEST control file. That is, it will collect some control, parameter and observation data; Figure 11.1 displays which data is actually used by PESTPP-PSO (shaded in grey). Some of this differs from most other PEST++ programs. It is important to note that PESTPP-PSO is designed to be compatible with PEST and its utilities (e.g., PESTCHEK). So, even if PESTPP-PSO is not using some of the variables listed in Figure 11.1, a dummy value must be entered in their place; this can be anything the user wants so long as it’s consistent with the format of the variable as defined by PEST (i.e., the dummy value for an integer variable should still be an integer, a character string should be a character string, etc.).
PESTPP-PSO must use another PEST++ calling program to initiate the “agents”. It is recommended that the PESTPP-GLM is used for this with the following command (see Chapter 5 for more details). In addition to the information contained in the main control file, PESTPP-PSO will need additional PSO-specific control variables. These will be contained in a separate PSO control file, which is defined by entering a line in the main control file that provides the path to the PSO specs file, and begins with the “++” identifier, i.e.,
++PSO(*case*.pso)
pcf
* control data
RSTFLE PESTMODE
NPAR NOBS NPARGP NPRIOR NOBSGP
NTPLFLE NINSFLE PRECIS DPOINT
RLAMBDA1 RLAMFAC PHIRATSUF PHIREDLAM NUMLAM
RELPARMAX FACPARMAX FACORIG
PHIREDSWH
NOPTMAX PHIREDSTP NPHISTP NPHINORED RELPARSTP NRELPAR
ICOV ICOR IEIG
* singular value decomposition
SVDMODE
MAXSING EIGTHRESH
EIGWRITE
* parameter groups
PARGPNME INCTYP DERINC DERINCLB FORCEN DERINCMUL DERMTHD
(one such line for each parameter group)
* parameter data
PARNME PARTRANS PARCHGLIM PARVAL1 PARLBND PARUBND PARGP SCALE OFFSET DERCOM
(one such line for each parameter)
PARNME PARTIED
(one such line for each tied parameter)
* observation groups
OBGNME
(one such line for each observation group)
* observation data
OBSNME OBSVAL WEIGHT OBGNME
(one such line for each observation)
* model command line
COMLINE
(one such line for each model command line)
* model input
TEMPFLE INFLE
(one such line for each template file)
* model output
INSFLE OUTFLE
(one such line for each instruction file)
* prior information
PILBL PIFAC * PARNME + PIFAC * log(PARNME) ... = PIVAL WEIGHT OBGNME
(one such line for each article of prior information)
* regularization
PHIMLIM PHIMACCEPT [FRACPHIM]
WFINIT WFMIN WFMAX
WFFAC WFTOL [IREGADJ]
++
++PSO(case.pst)
Figure 11.1. Variables comprising a minimalist PEST control file (see Figure 4.1), where the control variables used by PESTPP-PSO are shaded in grey. Note that the very last line designates the PSO control file.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 11
- **Subsection:** 11.1 Using PESTPP-PSO

### Additional Summaries
- **Higher-Level Summary:** Parallel PEST and BEOPEST parallelize model runs to reduce run time. Parallel PEST needs a run management file, while BEOPEST's is optional. Both distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Parallel PEST uses PAGENT agents, requires separate folders for agents, and shared signal files for communication. BEOPEST offers ease of use, faster communication, flexibility, and support for multiple command lines and surrogate models.
- **Detailed Summary:** Parallel PEST and BEOPEST parallelize model runs, reducing PEST run time. Parallel PEST requires a run management file, while BEOPEST's is optional. They distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Both store data in binary files for reduced memory needs.

### Related Context
- **Previous Summary:** PESTPP-PSO's *eqlog* transforms decision variables, using base 10 for the widest-range variable and scaling others to match its range. This equalizes variability for enhanced PSO performance.  Some variables may be untransformed or have expanded ranges. See *Siade et al*, (2019) for details.
- **Next Summary:** In PESTPP-PSO estimation mode (Figure 11.2),  PSO-specific control variables include RSTPSO (0=new, 1=restart), NOBJGP (always 1), NCON (number of constraints), NFORG (allowed failures), VERBOSE (verbosity level), NPOP (swarm size), C1/C2 (cognitive/social constants, ≤4.0), ISEED (random seed), INITP (0=random, 1=PARVAL1 + random, 2=external file, Section 11.2.3), VMAX (maximum velocity, 0<VMAX≤1), IINERT/FINERT/INITER (inertia parameters).

### Metadata
- **Keywords:** * control data, * model command line, * observation data, * observation groups, * parameter data, * parameter groups, * prior information, * regularization, * singular value decomposition, COMLINE, DERCOM, DERINC, DERINCLB, DERINCMUL, DERMTHD, DPOINT, EIGTHRESH, EIGWRITE, FACORIG, FACPARMAX, FORCEN, FRACPHIM, ICOR, ICOV, IEIG, INCTYP, INFLE, INSFLE, IREGADJ, MAXSING, NINSFLE, NOBS, NOBSGP, NOPTMAX, NPAR, NPARGP, NPHINORED, NPHISTP, NPRIOR, NRELPAR, NTPLFLE, NUMLAM, OBGNME, OBSNME, OBSVAL, OFFSET, OUTFLE, PARCHGLIM, PARGP, PARGPNME, PARLBND, PARNME, PARTIED, PARTRANS, PARUBND, PARVAL1, PESTMODE, PHIMACCEPT, PHIMLIM, PHIRATSUF, PHIREDLAM, PHIREDSTP, PHIREDSWH, PIFAC, PILBL, PIVAL, PRECIS, RELPARMAX, RELPARSTP, RLAMBDA1, RLAMFAC, RSTFLE, SCALE, SVDMODE, TEMPFLE, WFFAC, WFINIT, WFMAX, WFMIN, WFTOL
- **Chunk ID:** e0889828dd60
- **Chunk Index:** 1
- **Previous Chunk ID:** c66ecb1eac1c
- **Next Chunk ID:** 13fe2c26bb4f

---

## Context

### Summary
**PNULPAR-modified parameter sets can be used in a PEST run (NOPTMAX=0) to calculate objective functions.  For nonlinear models, a single iteration (NOPTMAX=1, using a JCO file with the `/i` switch,  JACUPDATE=999, PHIRATSUF=0.001, RLAMFAC=-4) may suffice.  For large null spaces, use SVD-assist (section 10.6.3, Part I). Increasing the solution space dimensionality increases efficiency but reduces diversity.**

### Header
**12.7.3 What to do Next**

### Content
Parameter values recorded in parameter value files generated by PNULPAR can be PARREPed into a PEST control file. NOPTMAX can be set to zero in this file and the objective function computed in each case. If the model is linear, this objective function should be similar to that achieved during the previous calibration exercise.
Where a model is nonlinear, the use of PNULPAR‑generated parameters will probably not result in a calibrated model. In many cases, however, parameter values can be adjusted back into calibration with very little effort, this often requiring only one PEST iteration. (If desired, set NOPTMAX to 1 in the governing PEST control file to ensure that only one iteration actually takes place.) Furthermore, this process can be made even more inexpensive by employing sensitivities residing in an existing JCO file (for example, the same JCO file as that read by PNULPAR). This can be achieved by starting PEST with the “/i” switch and providing the name of the pertinent JCO file when prompted accordingly.
When undertaking a single‑iteration PEST run under these conditions, the following may help.
1. Set the BROYDEN update parameter JACUPDATE to 999. Thus on the second and further attempts to upgrade parameter values during this single iteration, PEST will have improved the Jacobian matrix on whose basis these upgrades are computed, this resulting (hopefully) in a lower objective function.
2. Set the PHIRATSUF control variable very low (for example 0.001) and RLAMFAC to ‑4. Thus PEST will be forced to test a number of different Marquardt lambdas before the end of the iteration.
Hopefully, with the help of these strategies, an objective function can then be found which is as low as it can possibly be based on current sensitivities.
If the calibration null space is relatively large, then use of SVD‑assist for calibration adjustment of each PNULPAR‑generated parameter set can be achieved with a high level of model run efficiency, even if more than one iteration is required to reduce the objective function to a level at which the model is deemed to be “calibrated”. See section 10.6.3 of part I of this manual for details.
Whichever of the above methods is chosen to enforce calibration constraints on PNULPAR‑modified parameter sets, the higher that you inform PNULPAR is the dimensionality of the calibration solution space, the less work will be required to enforce these constraints. This is because the higher that PNULPAR believes the dimensions of the calibration solution space to be, the greater is the contribution made by the parameter field calculated during the previous calibration process to each PNULPAR‑generated parameter field. The user‑supplied solution space dimensionality therefore provides a “lever” through which you can increase the efficiency of attainment of parameter fields which respect calibration constraints (as embodied in respect for an objective function that is deemed to “calibrate” the model). The cost of such a speed‑up strategy is, of course, some reduction in the diversity of the calibration‑adjusted random parameter sets thus obtained.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software
- **Main Section:** 12. Nonlinear Error and Uncertainty
- **Subsection:** 12.7 PNULPAR

### Additional Summaries
- **Higher-Level Summary:** PEST uses pest.mmf to send messages before each run, indicating run type and parameter details. Different commands can be used for regular and derivative-calculating model runs, potentially reducing run time. Models can provide PEST with derivatives more efficiently, supporting various file formats. PEST control file variables manage model commands, messaging, and external derivatives.
- **Detailed Summary:** For SVD-assisted inversion in PEST with SVDA_EXTSUPER≠1, use model-provided base parameter derivatives. Set JACFILE=1 and DERCOM=0 for super parameters. External derivatives file must be uncompressed ASCII; JUPITER format and -1.11e33 values not supported. Base parameter JCO file needed for initial super parameter definition. SVDAPREP creates batch files if JACFILE=1.

### Related Context
- **Previous Summary:** PNULPAR modifies RANDPAR parameter sets to meet calibration constraints. It prompts for a post-calibration PEST control file (with JCO file),  confirmation of calibrated parameters ("y" or "n"), solution space dimensionality, optional Q<sup>1/2</sup>J matrix storage, input and output filename bases. It then modifies parameter sets based on null-space projection (Equation 12.7.2), preserving tied parameter ratios.  It halts if PESTMODE is not "estimation".
- **Next Summary:** RDMULRES reads data from multiple files (e.g., model1.out, model2.out, etc., from a batch file, Figure 12.2, or PEST runs using parval1.par, parval2.par, etc., and pestcase_svda.pst, Figure 12.3).  File names use an indicial integer.  -1.1E35 in model outputs indicates model failure; -1.22E35 indicates an abandoned run. A global record file (record.dat) can track results across multiple PEST runs.

### Metadata
- **Keywords:** JACUPDATE, NOPTMAX, PHIRATSUF, RLAMFAC, lambdas
- **Chunk ID:** f1e149007e9e
- **Chunk Index:** 1
- **Previous Chunk ID:** f00fef629bff
- **Next Chunk ID:** 15d6e85d239c

---

## Context

### Summary
**Variables RLAMBDA1, RLAMFAC, PHIRATSUF, PHIREDLAM, and NUMLAM on line five control Marquardt lambda selection in PEST (not used by PEST++). For PESTCHEK compatibility, set them to 10.0, -2.0, 0.3, 0.01, and 10, respectively.**

### Header
**4.6.6 Fifth Line**

### Content
The fifth line of the “control data” section of a PEST control file contains variables which control the way in which PEST selects a Marquardt lambda. Programs of the PEST++ suite which employ a Marquardt lambda do not read this line because they use their own lambda control variables. For PESTCHEK-friendliness, set RLAMBDA1, RLAMFAC, PHIRATSUF, PHIREDLAM and NUMLAM to 10.0, -2.0, 0.3, 0.01 and 10 respectively.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 4. The PEST Control File
- **Subsection:** 4.6 Control Data Section

### Additional Summaries
- **Higher-Level Summary:** Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.
- **Detailed Summary:** The optional "automatic user intervention" section (section 6.3) governs automatic user intervention, activated by setting DOAUI to "doaui" in the "control data" section.  If omitted, default values are used.

### Related Context
- **Previous Summary:** NTPFLE and NINSFLE (integers >1) specify template and instruction file counts.  PRECIS ("single") and DPOINT ("point") control parameter value formatting (not used by PEST++). NUMCOM (integer, 1 or omitted for single command lines) specifies the number of model command lines.  These variables are used by PEST but not PEST++.
- **Next Summary:** RELPARMAX, FACPARMAX (≥1.0), and FACORIG (often 0.001) in the "control data" section limit parameter changes per iteration in PESTPP-GLM to prevent overshooting and oscillations.  RELPARMAX < 1.0 is allowed only if bounds are not of opposite sign.  Default values of 10.0 are often suitable.

### Metadata
- **Keywords:** NUMLAM, PHIRATSUF, PHIREDLAM, RLAMBDA1, RLAMFAC
- **Chunk ID:** a02a8be1a203
- **Chunk Index:** 1
- **Previous Chunk ID:** 9813ada0b4b7
- **Next Chunk ID:** b8af6e056ac6

---
